<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CI/CD阿里云镜像仓库+docker+jenkins+webhook实现项目自动化部署</title>
    <url>/2021/06/16/CI-CD%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93-docker-jenkins-webhook%E5%AE%9E%E7%8E%B0%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>实现项目自动化部署，解放双手啦</p>
<span id="more"></span>

<p>这篇文章使用<code>Docker+Jenkins+阿里云镜像仓库</code>实现Go语言项目的CI/CD。</p>
<p>首先讲一下大致的实现思路：</p>
<ol>
<li>推送代码至Git服务器</li>
<li>阿里云镜像仓库自动构建镜像</li>
<li>触发Jenkins服务器配置的 Web Hooks</li>
<li>从Jenkins服务器进入远程应用服务器</li>
<li>从docker镜像仓库中拉取镜像</li>
<li>停止并删除该项目正在运行的docker容器</li>
<li>使用该新镜像构建并启动docker容器</li>
<li>删除其他旧版本镜像</li>
<li>完成</li>
</ol>
<p>然后讲一下实践过程中用到的一些技术点：</p>
<ul>
<li><p>Docker</p>
<p>  使用<code>Docker</code>的主要原因主要有，应用移植方便，并且可有效解决同一应用在不同服务器上部署带来的环境问题影响。</p>
</li>
<li><p>Docker Compose</p>
<p>  <code>docker-compose</code>也是由Docker提供的一个命令行工具，这里主要用于简化<code>Jenkins</code>服务器上对容器的操作，仅此而已，可直接使用<code>shell</code>脚本代替。</p>
</li>
<li><p>Jenkins</p>
<p>  <code>Jenkins</code>是一个自动化服务器，也可以作为简单的<code>CI/CD</code>服务器。</p>
</li>
</ul>
<ul>
<li><p>Git</p>
<p>  <code>Git</code>想必大家都不会陌生，这里同样使用它作为项目的代码管理仓库，并且利用它的<code>Web Hooks</code>，作为<code>Jenkins</code>任务构建的触发器。</p>
</li>
</ul>
<ul>
<li><p>镜像仓库</p>
<p>  这里选择阿里云提供的容器服务作为我们的镜像仓库，因为当git仓库代码更新后阿里云可以自动构建镜像。</p>
</li>
</ul>
<h1 id="安装-Jenkins"><a href="#安装-Jenkins" class="headerlink" title="安装 Jenkins"></a>安装 Jenkins</h1><ul>
<li>拉取 Jenkins 镜像<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull jenkins/jenkins:latest</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>编写 docker-compose.yml 文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">	<span class="attr">jks:</span></span><br><span class="line">		<span class="attr">image:</span> <span class="string">jenkins/jenkins:latest</span></span><br><span class="line">		<span class="attr">ports:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">			<span class="bullet">-</span> <span class="number">50000</span><span class="string">:50000</span></span><br><span class="line">		<span class="attr">volumes:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">/data/jenkins:/var/jenkins_home</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">/bin/docker:/bin/docker</span></span><br><span class="line">		<span class="attr">container_name:</span> <span class="string">jks</span></span><br><span class="line">		<span class="attr">user:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建用于挂载的 /data/jenkins 文件夹, 并修改该文件夹的拥有者为 ID=1000 的用户</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/jenkins</span><br><span class="line">chown -R 1000:1000 /data/jenkins</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 docker-compose 启动 jenkins 容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose -f /data/compose/docker-compose.yml up -d jks</span><br></pre></td></tr></table></figure>

<h1 id="安装-Jenkins-插件"><a href="#安装-Jenkins-插件" class="headerlink" title="安装 Jenkins 插件"></a>安装 Jenkins 插件</h1><ol>
<li><p>在浏览器输入 <a href="http://ip:8080/">http://IP:8080</a> 进入 <code>Jenkins</code> 管理页面</p>
</li>
<li><p>通过命令 <code>cat /data/jenkins/secrets/initialAdminPassword</code> 获取初始密码，对 Jenkins 进行解锁，解锁后先跳过插件安装（无需担心漏装推荐的插件，在后续安装插件过程中，会自动安装解锁后推荐的所有插件）</p>
</li>
<li><p>（可选）修改配置文件，并重启 Jenkins 容器，实现插件安装加速</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编辑jenkins配置文件</span></span><br><span class="line">vim /data/jenkins/updates/default.json</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行ex命令, 替换所有插件下载URL</span></span><br><span class="line">:1,$s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行ex命令, 替换连接测试URL</span></span><br><span class="line">:1,$s/http:\/\/www.google.com/https:\/\/www.baidu.com/g</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启jenkins容器</span></span><br><span class="line">docker-compose -f /data/compose/docker-compose.yml restart jks</span><br></pre></td></tr></table></figure>

<ul>
<li>进入Jenkins -&gt; Plugin Manager页面安装以下插件<ul>
<li>Localization: Chinese (Simplified)</li>
</ul>
</li>
</ul>
<h1 id="配置-Jenkins"><a href="#配置-Jenkins" class="headerlink" title="配置 Jenkins"></a>配置 Jenkins</h1><h2 id="构建任务"><a href="#构建任务" class="headerlink" title="构建任务"></a>构建任务</h2><ol>
<li><p>点击Jenkins -&gt; 新建任务，创建一个 Jenkins 任务</p>
</li>
<li><p>点击构建触发器</p>
<ul>
<li>勾选<strong>Generic Webhook Trigger</strong></li>
<li>在<code>token</code>那一栏填写自己的token，最好是项目名清晰明了<br><img src="/2021/06/16/CI-CD%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93-docker-jenkins-webhook%E5%AE%9E%E7%8E%B0%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210309132545.png"></li>
<li>然后通过 <code>http://用户名:用户APIToken 或者密码@IP:PORT/generic-webhook-trigger/invoke?token=你填写的TOKEN</code><br>例如：<code>http://admin:admin@127.0.0.1:8080/generic-webhook-trigger/invoke?token=test</code></li>
<li>在<a href="https://cr.console.aliyun.com/" title="阿里云镜像中心">阿里云镜像中心</a>创建仓库并填写触发器<br><img src="/2021/06/16/CI-CD%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93-docker-jenkins-webhook%E5%AE%9E%E7%8E%B0%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/%E8%A7%A6%E5%8F%91%E5%99%A8.png"></li>
</ul>
</li>
</ol>
<p>在jenkins任务构建中填写shell语句</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 容器名</span></span><br><span class="line">name=test1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器标签</span></span><br><span class="line">tag=latest</span><br><span class="line"><span class="meta">#</span><span class="bash"> 仓库域名</span></span><br><span class="line">domain=registry.cn-hangzhou.aliyuncs.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 仓库URL</span></span><br><span class="line">url=***/****</span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录阿里云镜像仓库</span></span><br><span class="line">docker login --username=**** --password=**** registry.cn-hangzhou.aliyuncs.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从阿里云镜像仓库中拉取镜像</span></span><br><span class="line">docker pull $domain/$url</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止该镜像正在运行的Docker容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash">line=`docker ps | grep <span class="variable">$name</span>`</span></span><br><span class="line">echo &quot;with argument&quot;</span><br><span class="line">if [ -n &quot;`docker ps | grep $name`&quot; ]; then</span><br><span class="line">	echo &quot;存在正在运行的$name容器, 正在使其停止运行...&quot;</span><br><span class="line">	docker stop $name</span><br><span class="line">	echo &quot;$name容器, 已停止运行&quot;</span><br><span class="line">fi</span><br><span class="line">echo &quot;with argument1&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除该镜像的Docker容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> line=`docker ps -a | grep <span class="variable">$name</span>`</span></span><br><span class="line">if [ -n &quot;`docker ps -a | grep $name`&quot; ]; then</span><br><span class="line">	echo &quot;存在$name容器, 对其进行删除...&quot;</span><br><span class="line">	docker rm $name</span><br><span class="line">	echo &quot;$name容器, 已被删除&quot;</span><br><span class="line">fi</span><br><span class="line">echo &quot;with argument2&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动容器</span></span><br><span class="line">docker run --rm --name $name -p 9090:9090 -d -v /usr/workspace/src/cicd:/home $domain/$url:$tag</span><br><span class="line"></span><br><span class="line">IFS=$&#x27;\n&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除多余镜像</span></span><br><span class="line">images=`docker images | grep none`</span><br><span class="line">for i in &quot;`docker images | grep none`&quot;</span><br><span class="line">	do</span><br><span class="line"><span class="meta">		#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$i</span></span></span><br><span class="line"><span class="meta">		#</span><span class="bash"> id=`<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$i</span>&quot;</span> | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>`</span></span><br><span class="line">		docker rmi `echo &quot;$i&quot; | awk &#x27;&#123;print $3&#125;&#x27;`</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>这就大功告成了</p>
<h2 id="附1"><a href="#附1" class="headerlink" title="附1"></a>附1</h2><p>Dockerfile文件参考</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#轻型scratch镜像</span><br><span class="line">FROM golang:alpine AS builder</span><br><span class="line"></span><br><span class="line"># 为我们的镜像设置必要的环境变量</span><br><span class="line">ENV GO111MODULE=on \</span><br><span class="line">    CGO_ENABLED=0 \</span><br><span class="line">    GOOS=linux \</span><br><span class="line">    GOARCH=amd64</span><br><span class="line"></span><br><span class="line"># 移动到工作目录：/build</span><br><span class="line">WORKDIR /build</span><br><span class="line"></span><br><span class="line"># 将代码复制到容器中</span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line"># 将我们的代码编译成二进制可执行文件 app</span><br><span class="line">RUN go build -o app .</span><br><span class="line"></span><br><span class="line">###################</span><br><span class="line"># 接下来创建一个小镜像</span><br><span class="line">###################</span><br><span class="line">FROM scratch</span><br><span class="line"></span><br><span class="line"># 复制文件或文件夹到镜像中</span><br><span class="line">#COPY data/log /log</span><br><span class="line"></span><br><span class="line"># 从builder镜像中把/dist/app 拷贝到当前目录</span><br><span class="line">COPY --from=builder /build/app /</span><br><span class="line"></span><br><span class="line"># 声明服务端口</span><br><span class="line">EXPOSE 9090</span><br><span class="line"></span><br><span class="line"># 需要运行的命令</span><br><span class="line">ENTRYPOINT [&quot;/app&quot;]</span><br></pre></td></tr></table></figure>

<p>demo地址：</p>
<p><a href="https://github.com/likewl/CICD">https://github.com/likewl/CICD</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>CI/CD</tag>
        <tag>docker</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O多路复用理解</title>
    <url>/2021/05/12/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>这篇文章我们将详细说明I/O多路复用的内容</p>
<span id="more"></span>

<blockquote>
<p>在了解I/O多路复用前，我们首先要了解 </p>
<ul>
<li><a href="/2021/05/19/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E">进程、线程</a></li>
<li><a href="/2021/05/19/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E">同步、异步</a></li>
<li><a href="/2021/05/19/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E">阻塞、非阻塞</a></li>
<li><a href="/2021/05/18/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-%E6%96%87%E4%BB%B6%E8%A1%A8%E9%A1%B9">文件描述符</a></li>
</ul>
</blockquote>
<h1 id="I-O的四种形式"><a href="#I-O的四种形式" class="headerlink" title="I/O的四种形式"></a>I/O的四种形式</h1><ul>
<li><p>同步阻塞形式</p>
</li>
<li><p>异步阻塞形式</p>
<blockquote>
<p>异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。</p>
</blockquote>
</li>
<li><p>同步非阻塞形式</p>
<blockquote>
<p>很多人会写阻塞的<code>read/write</code> 操作，但是别忘了可以对<code>fd</code>设置<code>O_NONBLOCK </code>标志位，这样就可以将同步操作变成非阻塞的了。</p>
</blockquote>
</li>
<li><p>异步非阻塞形式</p>
</li>
</ul>
<h1 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h1><p>要想客户端和服务器能在网络中通信，那必须得使用 Socket 编程，它是进程间通信里比较特别的方式，特别之处在于它是可以跨主机间通信。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>只使用一个进程来维护多个请求<br>一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做<strong>时分多路复用</strong>。</p>
<h2 id="TCP协议下的Socket"><a href="#TCP协议下的Socket" class="headerlink" title="TCP协议下的Socket"></a>TCP协议下的Socket</h2><p>TCP 协议的 Socket 程序的整个过程如下图：<br><img src="/2021/05/12/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%90%86%E8%A7%A3/socket%E5%85%A8%E8%BF%87%E7%A8%8B.png" alt="socket全过程"><br>有没有觉得读写 Socket 的方式，好像读写文件一样。</p>
<blockquote>
<p>基于 Linux 一切皆文件的理念，在内核中 Socket 也是以「文件」的形式存在的，也是有对应的文件描述符。<br>关于文件描述符的详细请看这里→<a href="/2021/05/18/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-%E6%96%87%E4%BB%B6%E8%A1%A8%E9%A1%B9">文件描述符/文件表项</a></p>
</blockquote>
<h2 id="select-poll"><a href="#select-poll" class="headerlink" title="select/poll"></a>select/poll</h2><p><code>select</code> 实现多路复用的方式是，将已连接的 Socket 都放到一个文件描述符集合，然后调用 select 函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过遍历文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。</p>
<p>所以，对于 select 这种方式，需要进行 <strong>2 次「遍历」</strong>文件描述符集合，一次是在内核态里，一个次是在用户态里 ，而且还会发生 <strong>2 次「拷贝」</strong>文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p>
<p><code>select</code>使用固定长度的 <code>BitsMap</code>，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 <code>FD_SETSIZE</code> 限制， 默认最大值为 <code>1024</code>，只能监听 <code>0~1023 </code>的文件描述符。</p>
<p>poll 不再用 <code>BitsMap</code> 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了<code>select</code>的文件描述符个数限制，当然<strong>还会受到系统文件描述符限制。</strong></p>
<p>但是 <code>poll </code>和 <code>select</code> 并没有太大的本质区别，都是使用「线性结构」存储进程关注的 <code>Socket </code>集合，因此都需要遍历文件描述符集合来找到可读或可写的 <code>Socket</code>，时间复杂度为 <code>O(n)</code>，而且也需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发数上来，性能的损耗会呈指数级增长。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//epoll_create 建立一个epoll对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;  </span><br><span class="line"><span class="comment">//epoll_ctl 向epoll对象中添加socket套接字；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">// epoll_wait 返回已经准备就绪事件的连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,<span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;  </span><br></pre></td></tr></table></figure>
<p>具体使用请看后面的<em>echo服务器示例</em></p>
<p>从下图你可以看到 <code>epoll</code> 相关的接口作用：</p>
<p><img src="/2021/05/12/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%90%86%E8%A7%A3/1616141449-ykDyCB-file_1616141448576.png" alt="1616141449-ykDyCB-file_1616141448576"></p>
<p>epoll 通过两个方面，很好解决了 select/poll 的问题。</p>
<p>第一点，epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删查一般时间复杂度是 <code>O(logn)</code>，通过对这棵黑红树进行操作，这样就不需要像 select/poll 每次操作时都传入整个 socket 集合，只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</p>
<p>第二点，epoll 使用事件驱动的机制，所有添加到epoll中的事件都会与<em>设备(如网卡)驱动程序**</em>建立回调关系<strong>，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做<code>ep_poll_callback</code>，它会把这样的事件放到上面的</strong>rdllist双向链表**中, 当用户调用<code>epoll_wait()</code>函数时，只会返回有事件发生的文件描述符的个数，不需要像 <code>select/poll</code> 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</p>
<p><img src="/2021/05/12/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%90%86%E8%A7%A3/epoll.png" alt="epoll"></p>
<p>epoll 支持两种事件触发模式，分别是<strong>边缘触发（<em>edge-triggered，ET</em>）</strong>和<strong>水平触发（<em>level-triggered，LT</em>）</strong>。</p>
<ul>
<li>水平触发：只要这个文件描述符还有数据可读，每次 <code>epoll_wait</code>都会返回它的事件，提醒用户程序去操作</li>
<li>边缘触发：当文件描述符上有新的I/O事件到来时，内核才会通知进程</li>
</ul>
<p>如果使用水平触发模式，当内核通知文件描述符可读写时，接下来还可以继续去检测它的状态，看它是否依然可读或可写。所以在收到通知后，没必要一次执行尽可能多的读写操作。</p>
<p>如果使用边缘触发模式，I/O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会循环从文件描述符读写数据，那么如果文件描述符是阻塞的，那这个一直读或一直写势必会在最后一次阻塞。所以，<strong>边缘触发模式一般和非阻塞 I/O 搭配使用</strong>，程序会一直执行 I/O 操作，直到系统调用（如 read 和 write）返回错误，错误类型为 <code>EAGAIN</code> 或<code> EWOULDBLOCK</code>。</p>
<p><img src="/2021/05/12/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%90%86%E8%A7%A3/%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F.png" alt="触发方式"></p>
<p>一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 <code>epoll_wait </code>的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。</p>
<p>select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。</p>
<p>另外，使用 I/O 多路复用时，最好搭配非阻塞 I/O 一起使用，Linux 手册关于 select 的内容中有如下说明：</p>
<blockquote>
<p>Under Linux, select() may report a socket file descriptor as “ready for reading”, while nevertheless a subsequent read blocks. This could for example happen when data has arrived but upon examination has wrong checksum and is discarded. There may be other circumstances in which a file descriptor is spuriously reported as ready. Thus it may be safer to use O_NONBLOCK on sockets that should not block.</p>
</blockquote>
<h3 id="为什么部分IO设备不需要CPU-题外话"><a href="#为什么部分IO设备不需要CPU-题外话" class="headerlink" title="为什么部分IO设备不需要CPU(题外话)"></a>为什么部分IO设备不需要CPU(题外话)</h3><p><code>字符设备</code>, 比如键盘, 打印机等, 还是得通过CPU的。<br><code>块设备</code>I/O模块增加DMA(Direct Memory Access 直接存储器)控制器. DMA控制器类似于一个小的CPU, 有自己的寄存器(记录主存地址和取到的字的count等). CPU可以发起一个DMA请求, 传入读写操作类型, 相关I/O设备地址, 内存的起始地址, 要操作的字数.然<br>后DMA就可以获取总线的控制权, 将一大块内存和外部I/O读入或写出.等操作完成后, 再通知CPU. 释放总线控制权。</p>
<h2 id="echo服务器"><a href="#echo服务器" class="headerlink" title="echo服务器"></a>echo服务器</h2><p>我们通过一个回射服务器程序来展示<code>epoll</code>的标准用法。先简要介绍<code>epoll</code>的接口。主要由三个函数组成：</p>
<ul>
<li><code>epoll_create</code>创建新的<code>epoll</code>实例，一般使用最新的<code>epoll_create1</code>调用</li>
<li><code>epoll_ctl</code>管理感兴趣的文件描述符和相应事件</li>
<li><code>epoll_wait</code>返回就绪的文件描述符，然后对它们进行I/O操作</li>
</ul>
<p>程序的主要流程如下：</p>
<ol>
<li>创建一个监听套接字<code>lfd</code>，调用<code>set_nonblocking</code>函数将其设置为非阻塞</li>
<li>调用<code>epoll_create1</code>函数创建一个<code>epoll</code>实例，对应的文件描述符为<code>epfd</code></li>
<li>将监听套接字<code>lfd</code>加入到<code>epfd</code>的事件列表<code>event</code>中，监听的事件为<code>EPOLLIN</code></li>
<li>进入死循环，<code>epoll_wait</code>函数一直阻塞，直到有事件发生。事件信息保存在<code>evlist</code>中</li>
<li>检查文件描述符及其事件：<ul>
<li>如果是发生在监听套接字<code>lfd</code>上的事件，则收到了一个客户请求，将返回的连接套接字<code>cfd</code>设置为边沿触发（EPOLLET）模式，加入到事件列表<code>event</code>中</li>
<li>如果是连接套接字<code>cfd</code>上发生的事件，对<code>EPOLLIN</code>事件，调用<code>do_echo</code>函数执行回射操作；对<code>EPOLLERR</code>或<code>EPOLLHUP</code>事件，则关闭描述符</li>
</ul>
</li>
</ol>
<p>全部代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT_NUM   40713</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">char</span> *msg)</span> </span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 fd 设置为非阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_nonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">if</span> ((flags = fcntl(fd, F_GETFL, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;ERROR fcntl F_GETFL&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;ERROR fcntl F_SETFL&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_echo</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c, buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = read(fd, &amp;c, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            error(<span class="string">&quot;ERROR read from client&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buf[cnt++] = c;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(fd, buf, cnt) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                error(<span class="string">&quot;ERROR write to client&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> epfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">evlist</span>;</span></span><br><span class="line">    </span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(PORT_NUM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;ERROR socket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    set_nonblocking(lfd);</span><br><span class="line">    <span class="keyword">if</span> (bind(lfd, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;ERROR bind&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(lfd, <span class="number">16</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;ERROR listen&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个epoll实例，对应的文件描述符为epfd</span></span><br><span class="line">    epfd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (epfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ERROR epoll_create1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将监听套接字 lfd 加入到 epfd 的事件列表 event 中，监听的事件为`EPOLLIN`</span></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = lfd;</span><br><span class="line">    <span class="comment">//对事件进行监听</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;event) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;ERROR epoll_ctl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    evlist = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct epoll_event)*MAX_EVENTS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> cfd;</span><br><span class="line">        <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">        <span class="comment">//epoll_wait函数一直阻塞，直到有事件发生。事件信息保存在evlist中</span></span><br><span class="line">        <span class="comment">//-1表示如果取不到东西，就无限等待</span></span><br><span class="line">        <span class="comment">//0代表立马返回</span></span><br><span class="line">        <span class="comment">//它会把传入的时间转为绝对时间</span></span><br><span class="line">        <span class="keyword">int</span> ready = epoll_wait(epfd, evlist, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ready == <span class="number">-1</span>) &#123;</span><br><span class="line">            error(<span class="string">&quot;ERROR epoll_wait&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ready; i++) &#123;</span><br><span class="line">            <span class="comment">//如果是 套接字lfd 就获取</span></span><br><span class="line">            <span class="keyword">if</span> (evlist[i].data.fd == lfd) &#123;</span><br><span class="line">                cfd = accept(lfd, (struct sockaddr *)&amp;client_addr, &amp;len);</span><br><span class="line">                <span class="keyword">if</span> (cfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;ERROR accept&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                set_nonblocking(cfd);</span><br><span class="line">                event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line">                event.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;event);</span><br><span class="line">                <span class="comment">//如果是可读事件发生,进行操作</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (evlist[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">                cfd = evlist[i].data.fd;</span><br><span class="line">                do_echo(cfd);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (evlist[i].events &amp; (EPOLLHUP | EPOLLERR)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (close(evlist[i].data.fd) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    error(<span class="string">&quot;ERROR close&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://leetcode-cn.com/circle/discuss/ylV7i6/">分享｜再也不怕被问 I/O 多路复用 | 技术人求职记 - 力扣（LeetCode） (leetcode-cn.com)</a></li>
<li><a href="https://panqiincs.me/2015/08/01/io-multiplexing-with-epoll/">I/O多路复用之epoll | 辛未羊的网络日志 (panqiincs.me)</a></li>
<li><a href="https://blog.csdn.net/daaikuaichuan/article/details/83862311?ivk_sa=1024320u">epoll原理详解及epoll反应堆模型</a></li>
<li><a href="https://journey-c.github.io/io-multiplexing/#5-epoll">Linux的I/O多路复用机制 - Journey-C</a></li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>I/O</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>go并发模型研究</title>
    <url>/2021/05/19/go%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>go 实现的是 CSP (Communicating Sequential Process，通讯顺序进程) 模型</p>
<span id="more"></span>

<h1 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h1><p>CSP (Communicating Sequential Process，通讯顺序进程) 模型是上个世纪七十年代提出的,<strong>不同于传统的多线程通过共享内存来通信</strong>，<strong>CSP 讲究的是 <em>以通信的方式来共享内存</em></strong>。用于描述<strong>两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型</strong>。 CSP 中<code>channel</code>是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的<code>channel</code>。</p>
<p>Golang 就是借用 CSP 模型的一些概念为之实现并发进行理论支持，其实从实际上出发，go 语言并没有完全实现了 CSP 模型的所有理论，仅仅是借用了 <code>process</code>和<code>channel</code>这两个概念。**<code>process</code>是在 go 语言上的表现就是 <code>goroutine</code> 是实际并发执行的实体<strong>，每个</strong>实体之间是通过<code>channel</code>通讯来实现数据共享**。</p>
<h1 id="chanel"><a href="#chanel" class="headerlink" title="chanel"></a>chanel</h1><p>Golang 中<code>channel</code>是被单独创建并且可以在<code>goroutine</code>并发实体之间传递，它的通信模式类似于 <code>boss-worker</code> 模式的，<strong>一个实体通过将消息发送到<code>channel</code> 中，然后又监听这个 <code>channel</code> 的实体处理</strong>，两个实体之间是匿名的，这个就实现实体中间的解耦，其中 <code>channel</code> 是同步的,一个消息被发送到 <code>channel</code> 中，最终是一定要被另外的实体消费掉的，在实现原理上其实类似一个阻塞的消息队列。</p>
<h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h1><p><code>Goroutine</code>是 Golang 实际并发执行的实体，它底层是使用协程(<code>coroutine</code>)实现并发，<code>coroutine</code>是一种运行在用户态的用户线程，类似于<code>greenthread</code>，go 底层选择使用<code>coroutine</code>的出发点是因为，它具有以下特点：</p>
<ul>
<li>用户空间 避免了内核态和用户态的切换导致的成本。</li>
<li>可以由语言和框架层进行调度。</li>
<li>更小的栈空间允许创建大量的实例。</li>
</ul>
<p>更多请看 →<a href="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3">线程/协程详解</a></p>
<h2 id="Goroutine-是异步执行的"><a href="#Goroutine-是异步执行的" class="headerlink" title="Goroutine 是异步执行的"></a>Goroutine 是异步执行的</h2><p>有的时候为了防止在结束 main 函数的时候结束掉<code>Goroutine</code>，所以需要同步等待，可以使用一下三种方式：</p>
<ul>
<li><p><strong>channel</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)    无缓冲的channel由于没有缓冲发送和接收需要同步.</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>) 有缓冲channel不要求发送和接收操作同步.</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">&quot;start working&quot;</span>)</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; &#125;()</span><br><span class="line">&lt;-ch <span class="comment">//会阻塞直到协程完成</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>sync.WaitGroup</strong></p>
<blockquote>
<p>在 sync 包中，提供了 WaitGroup ，它会等待它收集的所有 goroutine 任务全部完成。在 WaitGroup 里主要有三个方法:<br><strong>Add</strong>, 可以添加或减少 goroutine 的数量.<br><strong>Done</strong>, 相当于 Add(-1).<br><strong>Wait</strong>, 执行后会堵塞主线程，直到 WaitGroup 里的值减至 0.</p>
</blockquote>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">var</span> urls = []<span class="keyword">string</span>&#123;<span class="string">&quot;http://www.golang.org/&quot;</span>, <span class="string">&quot;http://www.google.com/&quot;</span>,&#125;</span><br><span class="line">	<span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(url <span class="keyword">string</span>)</span></span> &#123; <span class="keyword">defer</span> wg.Done()</span><br><span class="line">		http.Get(url) &#125;(url)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>context</strong></p>
<blockquote>
<p>context 包主要是用来处理多个 goroutine 之间共享数据，及多个 goroutine 的管理。context 包的核心是 struct Context，接口声明如下：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Context carries a deadline, cancelation signal, and request-scoped values</span></span><br><span class="line"><span class="comment">// across API boundaries. Its methods are safe for simultaneous use by multiple</span></span><br><span class="line"><span class="comment">// goroutines.</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Done 返回一个只能接受数据的channel类型，当该context关闭或者超时时间到了的时候，</span></span><br><span class="line">	<span class="comment">//该channel就会有一个取消信号</span></span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Err 在Done() 之后，返回context 取消的原因。</span></span><br><span class="line">	Err() error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Deadline 设置该context cancel的时间点</span></span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Value 允许 Context 对象携带request作用域的数据，该数据必须是线程安全的。</span></span><br><span class="line">	Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Context 对象是线程安全的，你可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。</p>
</li>
</ul>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="双协程交替打印-1-10"><a href="#双协程交替打印-1-10" class="headerlink" title="双协程交替打印 1-10"></a>双协程交替打印 1-10</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双协程交替打印1-10</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= <span class="number">10</span>; i += <span class="number">2</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;A:&quot;</span>, &lt;-a) <span class="comment">//等待打印</span></span><br><span class="line">			a &lt;- i                 <span class="comment">//传入，下面的协程接受</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(exit)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">9</span>; i += <span class="number">2</span> &#123;</span><br><span class="line">			a &lt;- i                 <span class="comment">//传入，上面的协程接受</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;B:&quot;</span>, &lt;-a) <span class="comment">//等待打印</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	&lt;-exit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>goroutine</tag>
        <tag>go并发模型</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp的三次握手和四次挥手</title>
    <url>/2021/05/24/tcp%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<p>这篇文章我们将详细聊一下 tcp 的三次握手和四次挥手</p>
<span id="more"></span>

<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>传输控制协议（TCP，Transmission Control Protocol）是一种<strong>面向连接的</strong>、<strong>可靠的</strong>、<strong>基于字节流的</strong> <strong>传输层</strong>通信协议。</p>
<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p>为了方便理解我们先看一个男女生聊天的问题<br>男孩想找女孩聊天<br><img src="/2021/05/24/tcp%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%83%85%E6%99%AF%E5%89%A7.png" alt="三次握手情景剧"><br>上面类似 tcp 三次握手，接下来我们详细说明一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SYN: 同步位（只有在连接请求和连接请求确认才为1）</span><br><span class="line">seq: 序号位（随机产生）</span><br><span class="line">ACK: 确认位</span><br><span class="line">ack: 确认号（期待下一次接收的序号，只有ACK=1时，ack才有用）</span><br></pre></td></tr></table></figure>

<ul>
<li>第一次握手:<br>客户端发送<strong>连接请求报文段</strong>,无应用层数据，此时状态由 LISTEN 变为<strong>SYN_SENT</strong><blockquote>
<p>SYN=1,seq=x(随机)</p>
</blockquote>
</li>
<li>第二次握手：<br>服务器为该 TCP 连接<strong>分配缓存和变量</strong>，并向客户端返回<strong>确认报文段</strong>，允许连接,无应用层数据，此时状态由 LISTEN 变为<strong>SYN_RECV</strong><blockquote>
<p>SYN=1,ACK=1,seq=y(随机),ack=x+1</p>
</blockquote>
</li>
<li>第三次握手：<br>客户端收到后，为该 TCP 连接<strong>分配缓存和变量</strong>，并向服务器返回确认的确认,可携带数据，双方状态<strong>ESTABLISHED</strong>。<blockquote>
<p>ACK=1,seq=x+1,ack=y+1</p>
</blockquote>
</li>
</ul>
<p><img src="/2021/05/24/tcp%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p>
<p><strong>注</strong>：由于第二次握手服务器会分配缓存和变量可能产生 SYN 洪宏攻击</p>
<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>咱们还是用男女聊天的问题来看一下 4 次挥手终止回话的情况<br><img src="/2021/05/24/tcp%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%83%85%E6%99%AF%E5%89%A7.png" alt="四次挥手情景剧"><br>接下来我们详细说明一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FIN: 结束位</span><br><span class="line">seq: 序号位</span><br><span class="line">ACK: 确认位</span><br><span class="line">ack: 确认号（期待下一次接收的序号，只有ACK=1时，ack才有用）</span><br></pre></td></tr></table></figure>

<p>客户端和服务器双方都可以结束回话，本文以客户端先结束为例</p>
<ul>
<li>第一次挥手<br>客户端发送<strong>连接释放报文段</strong>，停止发送数据，主动关闭 TCP 连接。<blockquote>
<p>FIN=1,seq=u</p>
</blockquote>
</li>
<li>第二次挥手<br>服务器返回一个确认报文段，客户到服务器这个连接方向就释放了，此时为<strong>半关闭状态</strong>。<blockquote>
<p>ACK=1,seq=v,ack=u+1</p>
</blockquote>
</li>
<li>第三次挥手<br>服务器发送完数据，就发送<strong>连接释放报文段</strong>，主动关闭 tcp 连接。<blockquote>
<p>FIN=1,ACK=1,seq=w,ack=u+1</p>
</blockquote>
</li>
<li>第四次挥手<br>客户端回送一个确认报文段，再等到时间等待计时器设置的 2MSL(最长报文段寿命)后，连接彻底关闭。<blockquote>
<p>ACK=1,seq=u+1,ack=w+1</p>
</blockquote>
</li>
</ul>
<p><img src="/2021/05/24/tcp%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p>
<h2 id="相关字段解释"><a href="#相关字段解释" class="headerlink" title="相关字段解释"></a>相关字段解释</h2><ul>
<li><strong>FIN_WAIT_1</strong>: 这个状态要好好解释一下，其实<code>FIN_WAIT_1</code>和<code>FIN_WAIT_2</code>状态的真正含义都是表示等待对方的<code>FIN</code>报文。<br>而这两种状态的区别 是：<code>FIN_WAIT_1</code>状态实际上是当<code>SOCKET</code>在<code>ESTABLISHED</code>状态时，它想主动关闭连接，向对方发送了 FIN 报文，此时该<code>SOCKET</code>即 进入到<code>FIN_WAIT_1</code>状态。<br>而当对方回应<code>ACK</code>报文后，则进入到 F<code>IN_WAIT_2</code>状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应 ACK 报文，所以<code>FIN_WAIT_1</code>状态一般是比较难见到的，而<code>FIN_WAIT_2</code>状态还有时常常可以用<code>netstat</code>看到。</li>
<li><strong>FIN_WAIT_2</strong>：上面已经详细解释了这种状态，实际上<code>FIN_WAIT_2</code>状态下的<code>SOCKET</code>，表示<strong>半连接</strong>，也即有一方要求 close 连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。<br>如果 <code>FIN_WAIT_1</code> 状态下，收到了对方同时带 <code>FIN</code> 标志和<code> ACK</code> 标志的报文时，可以直接进入到 <code>TIME_WAIT</code> 状态，而无须经过 <code>FIN_WAIT_2</code> 状态。</li>
<li><strong>CLOSING</strong>: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送 FIN 报文后，按理来说是应该先收到（或同时收到）对方的 ACK 报文，再收到对方的 FIN 报文。但是 CLOSING 状态表示你发送 FIN 报文后，并没有收到对方的 ACK 报文，反而却也收到了对方的 FIN 报文。<br>什么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时 close 一个 SOCKET 的话，那么就出现了双方同时发送 FIN 报 文的情况，也即会<strong>出现 CLOSING 状态，表示双方都正在关闭 SOCKET 连接</strong>。</li>
<li><strong>CLOSE_WAIT</strong>: <strong>这种状态的含义其实是表示在等待关闭</strong>。<br>怎么理解呢？当对方 close 一个 SOCKET 后发送 FIN 报文给自己，你系统毫无疑问地会回应一个 ACK 报文给对方，此时则进入到 <code>CLOSE_WAIT</code> 状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close 这个 SOCKET，发送 FIN 报文给对方，也即关闭连接。<strong>所以你在 <code>CLOSE_WAIT</code> 状态下，需要完成的事情是等待你去关闭连接。</strong></li>
<li><strong>LAST_ACK:</strong> 这个状态还是比较容易好理解的，<strong>它是被动关闭一方在发送 FIN 报文后，最后等待对方的 ACK 报文</strong>。当收到 <code>ACK</code> 报文后，也即可以进入到 <code>CLOSED</code> 可用状态了。</li>
</ul>
<h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><ol>
<li><p><strong>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</strong><br>这是因为服务端的<code>LISTEN</code>状态下的<code>SOCKET</code>当收到<code>SYN</code>报文的建连请求后，它可以把<code>ACK</code>和<code>SYN</code>放在一个报文里来发送。<br>但关闭连接时，当收到对方的<code>FIN</code>报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭<code>SOCKET</code>,也即你可能还需要发送一些数据给对方之后，再发送 FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的<code>ACK</code>报文和<code>FIN</code>报文多数情况下都是分开发送的。</p>
</li>
<li><p><strong>为什么 <code>TIME_WAIT</code> 状态还需要等 <code>2MSL</code> 后才能返回到 <code>CLOSED</code> 状态？</strong><br>因为虽然双方都同意关闭连接了，而且握手的 4 个报文也都发送完毕，按理可以直接回到 <code>CLOSED</code> 状态(就好比从 <code>SYN_SENT</code> 状态到 <code>ESTABLISH</code> 状态那样)，但是我们必须<strong>假想网络是不可靠的</strong>，你<strong>无法保证你(客户端)最后发送的 <code>ACK</code> 报文一定会被对方收到</strong>，就是说对方处于 <code>LAST_ACK</code> 状态下的 <code>SOCKET</code> 可能会因为超时未收到 <code>ACK</code> 报文，而重发 <code>FIN</code> 报文，所以这个 <code>TIME_WAIT</code> 状态的作用就是用来重发可能丢失的 <code>ACK </code>报文。</p>
</li>
<li><p><strong>关闭 TCP 连接一定需要 4 次挥手吗?</strong><br>不一定，4 次挥手关闭<code>TCP</code>连接是最安全的做法。但在有些时候，我们不喜欢 <code>TIME_WAIT</code> 状态(如当<code>MSL</code>数值设置过大导致服务器端有太多<code>TIME_WAIT</code>状态的 TCP 连接，减少这些条目数可以更快地关闭连接，为新连接释放更多资源)，这时我们可以通过设置 <code>SOCKET</code> 变量的 <code>SO_LINGER</code> 标志来避免 <code>SOCKET</code> 在 <code>close()</code>之后进入 <code>TIME_WAIT</code> 状态，这时将通过发送 <code>RST</code> 强制终止 TCP 连接(取代正常的 TCP 四次握手的终止方式)。但这并不是一个很好的主意,<code>TIME_WAIT</code>对于我们来说往往是有利的。</p>
</li>
<li><p><strong><code>accept()</code> <code>connect()</code> <code>listen()</code>对应三次握手什么阶段</strong></p>
<ul>
<li><strong>客户端的 Connect() 函数</strong>：是一个阻塞函数,通过 TCp 三次握手与服务器建立连接，客户端主动连接服务器，建立连接方式通过 TCP 三次握手通知 Linux 内核自动完成 TCP 三次握手连接，如果连接成功为 <code>0</code> ，失败返回值<code>-1</code><br>一般的情况下,客户端的 <code>connect</code> 函数 默认是阻塞行为 直到三次握手阶段成功为止。</li>
<li><strong>服务器端的 listen() 函数</strong>：不是一个阻塞函数,功能：将<strong>套接字</strong> 和 <strong>套接字对应队列的长度</strong>告诉 <code>Linux</code> 内核，他是被动连接的,一直监听来自不同客户端的请求</li>
<li><strong>服务器端的 listen() 函数</strong>:只要作用将 <code>socketfd</code> 变成被动的连接监听 <code>socket</code>，其中参数 <code>backlog</code> 作用是设置内核中队列的长度。</li>
<li><strong>客户端的 accept() 函数</strong>: 阻塞,从处于 <code>established</code> 状态的队列中取出完成的连接,当队列中没有完成连接时候会形成阻塞，直到取出队列中已完成连接的用户连接为止。</li>
</ul>
</li>
<li><p><strong>服务器没有及时调用 accept 函数取走完成连接的队列怎么办？</strong><br>服务器的连接队列满掉后，服务器不会对再对建立新连接的 <code>syn</code> 进行应答，所以客户端的 <code>connect</code> 就会返回 <code>ETIMEDOUT</code>。但实际上 Linux 的并不是这样的 当 TCP 连接队列满了之后 Linux 并不会书中所说的拒绝连接，只是会延时连接。</p>
</li>
</ol>
<h1 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h1><ol>
<li><a href="https://juejin.cn/post/6965761651588988942#heading-19">字节跳动 Java 岗一二三面全经过分享</a></li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划算法思路</title>
    <url>/2021/05/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<p>在这片文章中，我们总结了动态规划的基本思路，大致就分为三种</p>
<span id="more"></span>

<p>此文章整理自<code>CyC</code>大佬，github地址：</p>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md#leetcode-%E9%A2%98%E8%A7%A3---%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md#leetcode-%E9%A2%98%E8%A7%A3---%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92</a></p>
<h1 id="常见的背包问题"><a href="#常见的背包问题" class="headerlink" title="常见的背包问题"></a>常见的背包问题</h1><ul>
<li>组合问题</li>
<li>True、False问题</li>
<li>最大最小问题</li>
</ul>
<h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/description/" title="377. 组合总和 Ⅳ">377. 组合总和 Ⅳ</a></p>
<p><a href="https://leetcode-cn.com/problems/target-sum/description/" title="494. 目标和">494. 目标和</a></p>
<p><a href="https://leetcode-cn.com/problems/coin-change-2/description/" title="518. 零钱兑换 II">518. 零钱兑换 II</a></p>
<h2 id="True、False问题"><a href="#True、False问题" class="headerlink" title="True、False问题"></a>True、False问题</h2><p><a href="https://leetcode-cn.com/problems/word-break/" title="139. 单词拆分">139. 单词拆分</a></p>
<p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/description/" title="416. 分割等和子集">416. 分割等和子集</a></p>
<h2 id="最大最小问题"><a href="#最大最小问题" class="headerlink" title="最大最小问题"></a>最大最小问题</h2><p><a href="https://leetcode-cn.com/problems/ones-and-zeroes/description/" title="474. 一和零">474. 一和零</a></p>
<p><a href="https://leetcode-cn.com/problems/coin-change/description/" title="322. 零钱兑换">322. 零钱兑换</a></p>
<h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><h2 id="组合问题公式"><a href="#组合问题公式" class="headerlink" title="组合问题公式"></a>组合问题公式</h2><pre><code>dp[i] += dp[i-num]
</code></pre>
<h2 id="True、False问题公式"><a href="#True、False问题公式" class="headerlink" title="True、False问题公式"></a>True、False问题公式</h2><pre><code>dp[i] = dp[i] or dp[i-num]
</code></pre>
<h2 id="最大最小问题公式"><a href="#最大最小问题公式" class="headerlink" title="最大最小问题公式"></a>最大最小问题公式</h2><pre><code>dp[i] = min(dp[i], dp[i-num]+1)或者dp[i] = max(dp[i], dp[i-num]+1)
</code></pre>
<p>以上三组公式是解决对应问题的核心公式。</p>
<h1 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h1><p>当然拿到问题后，需要做到以下几个步骤：</p>
<ol>
<li>分析是否为背包问题。</li>
<li>是以上三种背包问题中的哪一种。</li>
<li>是0-1背包问题还是完全背包问题。也就是题目给的nums数组中的元素是否可以重复使用。</li>
<li>如果是<strong>组合问题</strong>，<strong>是否需要考虑元素之间的顺序</strong>。需要考虑顺序有顺序的解法，不需要考虑顺序又有对应的解法。</li>
</ol>
<h2 id="背包问题特征"><a href="#背包问题特征" class="headerlink" title="背包问题特征"></a>背包问题特征</h2><p>给定一个<code>target</code>，<code>target</code>可以是数字也可以是字符串，再给定一个数组<code>nums</code>，<code>nums</code>中装的可能是数字，也可能是字符串，<strong>问</strong>：能否使用<code>nums</code>中的元素做各种排列组合得到<code>target</code>。</p>
<h1 id="背包问题技巧"><a href="#背包问题技巧" class="headerlink" title="背包问题技巧"></a>背包问题技巧</h1><p>如果是<strong>0-1背包</strong>，即数组中的<strong>元素不可重复使用</strong>，<strong>nums放在外循环</strong>，<strong>target在内循环</strong>，且<strong>内循环倒序</strong>；</p>
<pre><code>for num in nums:
    for i in range(target, nums-1, -1):
</code></pre>
<p>如果是<strong>完全背包</strong>，即数组中的<strong>元素可重复使用</strong>，<strong>nums放在外循环</strong>，<strong>target在内循环</strong>。且<strong>内循环正序</strong>。</p>
<pre><code>for num in nums:
    for i in range(nums, target+1):
</code></pre>
<p>如果组合问题需<strong>考虑元素之间的顺序</strong>，需将<strong>target放在外循环</strong>，将<strong>nums放在内循环</strong>。</p>
<pre><code>for i in range(1, target+1):
    for num in nums:
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>思路</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>文件描述符/文件表项</title>
    <url>/2021/05/18/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-%E6%96%87%E4%BB%B6%E8%A1%A8%E9%A1%B9/</url>
    <content><![CDATA[<p>从Linux的层次角度来说，在用户空间是存在这样的概念的，这个概念是存在内核空间的，而且是针对打开的文件的！</p>
<span id="more"></span>

<h1 id="进程表"><a href="#进程表" class="headerlink" title="进程表"></a>进程表</h1><p>也称进程控制块PCB，由结构<code>task_struct</code>所定义的数据结构。<code>task_struct</code>结构体专门用于存放进程在运行过程中，所涉及到的所有与进程相关的信息。这个结构体的成员项非常多，多达近300个。其中，文件描述符表就被包含在了<code>task_struct</code>结构体当中。在进程运行结束后，进程表所占用的内存空间，会被释放。</p>
<p>打开一个文件的内核数据结构图</p>
<p><img src="/2021/05/18/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-%E6%96%87%E4%BB%B6%E8%A1%A8%E9%A1%B9/%E8%BF%9B%E7%A8%8B%E8%A1%A8.jpg" alt="关系图"></p>
<h1 id="三种数据结构"><a href="#三种数据结构" class="headerlink" title="三种数据结构"></a>三种数据结构</h1><blockquote>
<p>从Linux的层次角度来说，在用户空间是存在这样的概念的，这个概念是存在内核空间的，而且是针对打开的文件的！<br>内核用三种数据结构来描述一个打开的文件。</p>
</blockquote>
<h2 id="文件描述符表："><a href="#文件描述符表：" class="headerlink" title="文件描述符表："></a>文件描述符表：</h2><p><code>open</code>打开文件后，会在进程的<code>task_struct</code>结构体中，创建相应的结构体，用以存放打开文件的相关信息。对文件进行读写等操作时，会用到这些信息，这个数据结构就是我们要讲的<code>文件描述符表</code>。<br>每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的文件描述符表项指向<code>文件表</code>中的一个表项。</p>
<h2 id="文件表"><a href="#文件表" class="headerlink" title="文件表"></a>文件表</h2><p>所有”打开的文件”的集合!<br>每个磁盘文件在打开时都会在内核中建立一个<strong>文件表项</strong>，内核为所有打开文件维持一张文件表。<br>每个<strong>文件表项</strong>包括：</p>
<ul>
<li>文件状态标志：读、写、添写、同步、非阻塞等</li>
<li>当前文件偏移量</li>
<li>指向该文件v节点表项的指针</li>
</ul>
<h3 id="文件状态标志"><a href="#文件状态标志" class="headerlink" title="文件状态标志"></a>文件状态标志</h3><p>文件状态标志就是open文件时指定的<code>O_RDONLY</code>、<code>O_WRONLY</code>、<code>O_RDWR</code>等操作权限。open打开文件成功后，就会将文件状态标志保存到文件表中。在对文件执行操作时，会先检查文件状态标志，看看有没有操作权限，然后再去操作文件。</p>
<h3 id="文件偏移量"><a href="#文件偏移量" class="headerlink" title="文件偏移量"></a>文件偏移量</h3><p>文件当前读写位置与文件开始位置的距离（字节数）。</p>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>在<code>read</code>、<code>write</code>等操作文件时，会根据底层具体情况的不同，调用不同的函数来实现读写。在V节点里面保存了这些不同函数的函数指针，方便调用。</p>
<h2 id="v-node"><a href="#v-node" class="headerlink" title="v-node"></a>v-node</h2><p><code>v-node</code> 在(<code>v-node table</code>) 。同文件表一样，所有的进程共享这张<code>v-node表</code>。<br>每个打开文件(或设备)都有个v节点结构。<br>v节点包含：</p>
<ul>
<li>文件类型</li>
<li>对此文件进行各种操作的函数指针。 </li>
</ul>
<p>对于大多数文件，v节点还包含了该文件的i节点（索引节点）。</p>
<p>i节点包含：</p>
<ul>
<li>文件的所有者</li>
<li>文件长度</li>
<li>文件所在设备</li>
<li>指向文件实际在磁盘上所在位置的指针。</li>
</ul>
<h3 id="文件长度"><a href="#文件长度" class="headerlink" title="文件长度"></a>文件长度</h3><p>记录了文件当前的长度，文件长度是动态更新的。</p>
<p><strong>注</strong>：</p>
<ol>
<li>在文件表或者v索引节点中都有索引计数 (即当前指向该表项的描述符表项数)，引用计数为0的时候就可以收回此表项</li>
<li>fork后父子进程各自的每一个打开的文件描述符共享同一个文件表项</li>
</ol>
<p>参考地址：<br><a href="http://emb.hqyj.com/Column/4458.html">什么是＂文件表项＂</a><br><a href="https://zhuanlan.zhihu.com/p/56251739">进程表和文件描述表</a><br><a href="https://www.cnblogs.com/tianzeng/p/11037229.html">文件描述符标志/文件表项</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>文件描述符</tag>
        <tag>文件表项</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>线程/协程详解</title>
    <url>/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>之前一篇文章简单介绍了进程和线程，这篇文章我们将介绍一下轻量级进程、线程和协程</p>
<span id="more"></span>

<blockquote>
<p>修改记录</p>
<ul>
<li>2021-5-26 修改并完善 内核态和用户态切换方式的描述 #<a href="#%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2">如何切换</a></li>
</ul>
</blockquote>
<p>在说这写概念之前，我们需要了解一下什么是<code>内核态</code>和<code>用户态</code></p>
<h1 id="内核态-用户态"><a href="#内核态-用户态" class="headerlink" title="内核态/用户态"></a>内核态/用户态</h1><p>由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 :<strong>用户态</strong> 和 <strong>内核态</strong></p>
<ul>
<li><strong>内核态</strong>: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡。CPU也可以将自己从一个程序切换到另一个程序</li>
<li><strong>用户态</strong>: 只能受限的访问内存, 且不允许访问外围设备。 占用CPU的能力被剥夺, CPU资源可以被其他程序获取</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>用户空间中的代码被限制了只能使用一个局部的内存空间，我们说这些程序在<strong>用户态（User Mode）</strong> 执行。<br>内核空间中的代码可以访问所有内存，我们称这些程序在<strong>内核态（Kernal Mode）</strong> 执行。</p>
<h2 id="如何切换"><a href="#如何切换" class="headerlink" title="如何切换"></a>如何切换</h2><p>所有用户程序都是运行在用户态的, 但是有时候程序确实需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等. 而唯一可以做这些事情的就是操作系统, 所以此时程序就需要先操作系统请求以程序的名义来执行这些操作.</p>
<p>这时需要一个这样的机制: 用户态程序切换到内核态, 但是不能控制在内核态中执行的指令</p>
<p>这种机制叫<strong>系统调用</strong>, 在CPU中的实现称之为<strong>陷阱指令(Trap Instruction)</strong></p>
<p>他们的工作流程如下:</p>
<ol>
<li>用户态程序将一些<strong>必要参数放在寄存器</strong>中，使操作系统知晓是哪种系统调用。</li>
<li>用户态程序执行<strong>陷入指令</strong>（非特权指令），引发<strong>内中断</strong>。</li>
<li>CPU切换到内核态, 并判断中断信号的原因（由于执行trap指令），执行相应的特权指令, 这些特权指令是操作系统的一部分, 他们具有内存保护, 不可被用户态程序访问。</li>
<li>系统调用完成后, 操作系统会重置CPU为用户态并返回系统调用的结果</li>
</ol>
<p><img src="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.png" alt="系统调用.png"><br>内核程序执行在内核态（Kernal Mode），用户程序执行在用户态（User Mode）。当发生系统调用时，用户态的程序发起系统调用。因为<strong>系统调用中牵扯特权指令，用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断)<strong>。发生中断后，</strong>当前 CPU 执行的程序会中断，跳转到中断处理程序。内核程序开始执行，也就是开始处理系统调用。内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。</strong></p>
<h3 id="切换方式"><a href="#切换方式" class="headerlink" title="切换方式"></a>切换方式</h3><ul>
<li><p><strong>用户态转切换到内核态</strong>：主要是用过<strong>系统调用</strong>（陷入指令），可以认为是用户进程主动发起的。</p>
</li>
<li><p><strong>系统从内核态切换到用户态</strong>：执行一条<strong>特权指令</strong>——修改PSW（程序状态字寄存器）的标志位为“用户态”，意味着操作系统将主动让出CPU的使用权</p>
</li>
</ul>
<h1 id="线程-协程"><a href="#线程-协程" class="headerlink" title="线程/协程"></a>线程/协程</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><blockquote>
<p>内核通过操纵调度器（Thread Scheduler）对内核线程进行调度，并负责将线程的任务映射到各个处理器上</p>
</blockquote>
<p>每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情。支持多线程的内核就叫做多线程内核（Multi-Threads Kernel）。</p>
<p>线程分为用户态线程和内核态线程</p>
<h3 id="用户态线程"><a href="#用户态线程" class="headerlink" title="用户态线程"></a>用户态线程</h3><p>用户态线程也称作用户级线程（User Level Thread）。操作系统内核并不知道它的存在，它完全是在用户空间中创建。<br>而这里的用户线程指的是<strong>完全建立在用户空间的线程库</strong>，用户线程的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。因此这种线程的操作是极其快速的且低消耗的。</p>
<p>用户级线程有很多<strong>优势</strong>：</p>
<ul>
<li><strong>管理开销小</strong>：创建、销毁不需要系统调用。</li>
<li><strong>切换成本低</strong>：用户空间程序可以自己维护，不需要走操作系统调度。</li>
</ul>
<p>但是这种线程也有很多的<strong>缺点</strong>：</p>
<ul>
<li><strong>与内核协作成本高</strong>：比如这种线程完全是用户空间程序在管理，当它进行 I/O 的时候，无法利用到内核的优势，需要频繁进行用户态到内核态的切换。</li>
<li><strong>线程间协作成本高</strong>：设想两个线程需要通信，通信需要 I/O，I/O 需要系统调用，因此用户态线程需要支付额外的系统调用成本。</li>
<li><strong>无法利用多核优势</strong>(N:1模型中)：比如操作系统调度的仍然是这个线程所属的进程，所以无论每次一个进程有多少用户态的线程，都只能并发执行一个线程，因此一个进程的多个线程无法利用多核的优势。</li>
<li><strong>操作系统无法针对线程调度进行优化</strong>：当一个进程的一个用户态线程阻塞（Block）了，操作系统无法及时发现和处理阻塞问题，它不会更换执行其他线程，从而造成资源浪费。</li>
</ul>
<h3 id="内核态线程"><a href="#内核态线程" class="headerlink" title="内核态线程"></a>内核态线程</h3><p>内核态线程也称作内核级线程（Kernel Level Thread）。这种线程执行在内核态，可以通过系统调用创造一个内核级线程。<strong>内核态线程是处理机分配的基本单位</strong>。</p>
<p>内核级线程有很多<strong>优势</strong>：</p>
<ul>
<li><strong>可以利用多核 CPU 优势</strong>：内核拥有较高权限，因此可以在多个 CPU 核心上执行内核线程。</li>
<li><strong>操作系统级优化</strong>：内核中的线程操作 I/O 不需要进行系统调用；一个内核线程阻塞了，可以立即让另一个执行。</li>
</ul>
<p>当然内核线程也有一些<strong>缺点</strong>：</p>
<ul>
<li><strong>创建成本高</strong>：创建的时候需要系统调用，也就是切换到内核态。</li>
<li><strong>扩展性差</strong>：由一个内核程序管理，不可能数量太多。</li>
<li><strong>切换成本较高</strong>：切换的时候，也同样存在需要内核操作，需要切换内核态。</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>用户态线程调度完全由<strong>进程</strong>负责，通常就是由进程的<strong>主线程</strong>负责。相当于进程主线程的延展，使用的是操作系统分配给进程主线程的时间片段。内核线程由<strong>内核维护</strong>，由操作系统调度。</p>
<p>用户态线程无法跨核心，一个进程的多个用户态线程<strong>不能并发</strong>，<strong>阻塞一个用户态线程会导致进程的主线程阻塞，直接交出执行权限</strong>。这些都是用户态线程的劣势。<br><strong>内核线程可以独立执行，操作系统会分配<em>时间片段</em></strong>。因此内核态线程更完整，也称作轻量级进程。内核态线程创建成本高，切换成本高，创建太多还会给调度算法增加压力，因此不会太多。</p>
<h3 id="三种线程模型"><a href="#三种线程模型" class="headerlink" title="三种线程模型"></a>三种线程模型</h3><p><strong>如果有一个用户态的进程，它下面有多个线程。如果这个进程想要执行下面的某一个线程，应该如何做呢？</strong></p>
<blockquote>
<p>比较常见的一种方式，就是将需要执行的程序，让一个内核线程去执行。毕竟，内核线程是真正的线程。因为它会分配到 CPU 的执行资源。<br>如果一个进程所有的线程都要自己调度，相当于在进程的主线程中实现分时算法调度每一个线程，也就是所有线程都用操作系统分配给主线程的时间片段执行。这种做法，相当于操作系统调度进程的主线程；进程的主线程进行二级调度，调度自己内部的线程。<br>这样操作劣势非常明显，比如无法利用多核优势，每个线程调度分配到的时间较少，而且这种线程在阻塞场景下会直接交出整个进程的执行权限。</p>
</blockquote>
<p>由此可见，<strong>用户态线程创建成本低，问题明显，不可以利用多核</strong>。<strong>内核态线程，创建成本高，可以利用多核，切换速度慢</strong>。因此通常我们会在内核中预先创建一些线程，并反复利用这些线程。<br>实际操作中，往往结合两者优势，将用户态线程附着在内核态线程中执行。</p>
<p>用户态线程和内核态线程之间的映射关系如下：</p>
<ul>
<li><p><strong>N:1模型</strong><br><strong>多个用户空间线程在1个内核空间线程上运行</strong>。优势是<strong>上下文切换非常快</strong>，因为只有一个内核线程，用户线程不需要频繁系统调用，但是<strong>无法利用多核系统的优点</strong>。<br><img src="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/%E5%A4%9A%E5%AF%B9%E4%B8%80.png" alt="多对一.png"></p>
</li>
<li><p><strong>1:1模型</strong>[pthread线程库–NPTL(Native POSIX Threading Library)]<br><strong>1个内核空间线程运行一个用户空间线程</strong>。这种<strong>充分利用了多核系统的优势</strong>但是<strong>上下文切换非常慢</strong>，因为每一次调度都会在用户态和内核态之间切换，而且用<strong>户线程数量受到限制</strong>。POSIX线程模型(pthread)就是这么做的。</p>
</li>
</ul>
<p><img src="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/%E4%B8%80%E5%AF%B9%E4%B8%80.png" alt="一对一.png"></p>
<ul>
<li><strong>M:N模型</strong><br><strong>内核开启多个内核线程，一个内核空间线程对应多个用户空间线程</strong>。效率非常高，但是管理复杂。</li>
</ul>
<p><img src="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/%E5%A4%9A%E5%AF%B9%E5%A4%9A.png" alt="多对多.png"></p>
<h3 id="轻量级进程（Light-Weight-Process-LWP）"><a href="#轻量级进程（Light-Weight-Process-LWP）" class="headerlink" title="轻量级进程（Light Weight Process LWP）"></a>轻量级进程（Light Weight Process LWP）</h3><blockquote>
<p>在实际程序中我们一般不直接使用内核线程，用户线程与内核线程之间需要一种中间数据结构，它由内核支持且是内核线程的高级抽象，这个高级接口被称为轻量级进程（Light Weight Process）</p>
</blockquote>
<p>轻量级进程就是我们通常意义上所讲的线程，当然也属于用户线程；由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1:1的关系称为一对一的线程模型。</p>
<p>LWP虽然本质上属于用户线程，但LWP线程库是建立在内核之上的，LWP的许多操作都要进行系统调用，因此效率不高。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93.png" alt="线程调度模型总结.png"></p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><blockquote>
<p>本文将以<code>golang</code>中的协程为例展开</p>
</blockquote>
<p>对于进程、线程，都是有内核进行调度，有CPU时间片的概念，进行<strong>抢占式调度</strong>。<br>协程可以理解为<strong>用户态的轻量级的非抢占式的线程</strong>。适用于IO密集型。</p>
<p>协程，又称微线程，纤程。英文名Coroutine。协程的调用有点类似子程序，如程序A调用了子程序B，子程序B调用了子程序C，当子程序C结束了返回子程序B继续执行之后的逻辑，当子程序B运行结束了返回程序A，直到程序A运行结束。但是和子程序相比，<strong>协程有挂起的概念，协程可以挂起跳转执行其他协程，合适的时机再跳转回来</strong>。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>用户态</strong>:协程是在用户态实现调度。</li>
<li><strong>轻量级</strong>:协程不用内核调度，不用再内核态与用户态之间切换。</li>
<li><strong>非抢占</strong>:协程是由用户自己实现调度，协程自己主动交出CPU的。</li>
</ul>
<h3 id="go的协程调度原理"><a href="#go的协程调度原理" class="headerlink" title="go的协程调度原理"></a>go的协程调度原理</h3><p>go中的<code>goroutine</code>本质上就是协程，但是<strong>完全运行在用户态</strong>，借鉴了M:N模型。如下图<br><img src="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/gmp.jpg" alt="gmp.jpg"></p>
<p>相比其他语言，golang采用了GMP模型管理协程，更加高效，但是管理非常复杂。</p>
<ul>
<li>M：指的是<code>Machine</code>,一个M直接关联了一个内核线程。由操作系统管理。</li>
<li>G：指的是<code>goroutine</code>,其实本质上也是一种轻量级的线程。包括了<strong>调用栈</strong>，重要的<strong>调度信息</strong>，例如<code>channel</code>等。</li>
<li>P：指的是<code>Processor</code>，代表了<code>M</code>所需的上下文环境，也是处理用户级代码逻辑的处理器，它负责衔接<code>M</code>和<code>G</code>的调度上下文，将等待执行的<code>G</code>与<code>M</code>对接。</li>
</ul>
<h3 id="G-M-P三者的关系与特点"><a href="#G-M-P三者的关系与特点" class="headerlink" title="G-M-P三者的关系与特点"></a>G-M-P三者的关系与特点</h3><ul>
<li><code>P</code>的个数取决于设置的<code>GOMAXPROCS</code>,<strong><code>P</code>其实限定了<code>golang</code>调度其的最大并发度</strong>。go新版本默认使用最大内核数，比如你有8核处理器，那么P的数量就是8</li>
<li><code>M</code>的数量和<code>P</code>不一定匹配，可以设置很多<code>M</code>，**<code>M</code>和<code>P</code>绑定后才可运行和对G进行调度**，多余的<code>M</code>处于休眠状态</li>
<li><code>p</code>包含一个<strong>LRQ（Local Run Queue）本地运行队列</strong>，这里面保存着<strong>P需要执行的协程G的队列</strong><br>除了每个P自身保存的G的队列外，<strong>调度器还拥有一个全局的G队列GRQ（Global Run Queue）</strong>，这个队列存储的是<strong>所有未分配的协程G</strong>。</li>
</ul>
<p>单核主机下的协程运行图：<br><img src="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/2.jpg" alt="2.jpg"><br>红色部分表示挂起和休眠，黄色部分表示准备就绪等待运行，绿色部分表示正在运行。</p>
<hr>
<p>单核主机只有一个处理器P，但是系统初始化了两个线程M0和M1，处理器P优先绑定了M0线程，M1进入休眠状态。<br>P的LRQ队列里有G1,G2,G3等待处理。P目前正在处理G0,全局等待队列GRQ里保存着G4,G5，表示这两个协程还未分配给P。<br>如果G0在短时间内处理完，P就会从LRQ中取出G1继续处理。并且将GRQ全局队列中的部分协程加入LRQ中。<br><img src="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/3.jpg" alt="3.jpg"></p>
<hr>
<p>假设现在G1处理速度很慢，系统就会让M0线程休眠，挂起协程G1，唤醒线程M1进行处理其他的协程。这里M1会将M0未处理的协程取走处理。<br><img src="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/4.jpg" alt="4.jpg"></p>
<hr>
<p>等到M1协程队列中所有协程处理完再次唤醒M0，或者M1处理某个协程时间较长被挂起，M0也会被唤醒。</p>
<hr>
<p>上面的讨论是单核主机情况，如果是多核的，就会运行多个P和M，如图<br><img src="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/5.jpg" alt="5.jpg"></p>
<p>M0和M1分别运行在不同的内核中，M0处理G1,G2,G3，M1处理G4,G5,G6。</p>
<blockquote>
<p><strong>有人会问，当M0处理完所有的协程，而M1还未处理完，系统会如何做呢？</strong><br>  M0会取走M1的一半数量未处理的协程。</p>
</blockquote>
<p>golang协程设计非常优秀，一方面极大的利用了内核线程和处理器资源，另一方面每个处理器的LRQ队列的<strong>协程都处于用户态，这些协程的处理和挂起操作都是用户态的，协程切换开销非常小</strong>。相比其他语言的线程设计，更加轻量和高效。</p>
<h1 id="Linux使用的线程库"><a href="#Linux使用的线程库" class="headerlink" title="Linux使用的线程库"></a>Linux使用的线程库</h1><p><code>LinuxThreads</code>是<strong>用户空间的线程库</strong>，所采用的是<strong>线程-进程1对1模型(即一个用户线程对应一个轻量级进程，而一个轻量级进程对应一个特定的内核线程</strong>)，将线程的调度等同于进程的调度，调度交由内核完成，而线程的创建、同步、销毁由核外线程库完成（LinuxThtreads已绑定到 GLIBC中发行）。</p>
<h1 id="相关疑问"><a href="#相关疑问" class="headerlink" title="相关疑问"></a>相关疑问</h1><ol>
<li><p><strong>难道不是用户态的进程创建用户态的线程，内核态的进程创建内核态的线程吗？</strong></p>
<blockquote>
<p>其实不是，进程可以通过 <strong>API</strong> 创建用户态的线程，也可以通过<strong>系统调用</strong>创建内核态的线程，接下来我们说说用户态的线程和内核态的线程。<br>例如用<code>kthread_create</code>创建内核态线程，用<code>pthread_create</code>创建用户态线程(1:1模型)</p>
</blockquote>
</li>
<li><p><strong>用户态线程怎么用内核态线程执行程序？</strong></p>
<blockquote>
<p>程序是存储在内存中的指令，用户态线程是可以准备好程序让内核态线程执行的。</p>
</blockquote>
</li>
</ol>
<h1 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h1><ol>
<li><a href="https://www.cnblogs.com/shangxiaofei/p/5567776.html">多线程之：用户态和内核态的区别</a></li>
<li><a href="https://blog.csdn.net/gatieme/article/details/51481863">内核线程、轻量级进程、用户线程三种线程概念解惑（线程≠轻量级进程）</a></li>
<li><a href="https://blog.csdn.net/m0_50654102/article/details/116065035">用户态线程和内核态线程有什么区别？</a></li>
<li><a href="https://www.jianshu.com/p/4afa0679851d">【深度知识】GO语言的goroutine并发原理和调度机制</a></li>
<li><a href="https://www.limerence2017.com/2019/11/05/golang17/">图解Go协程调度原理，小白都能理解</a></li>
<li><a href="https://www.icode9.com/content-3-198795.html">Linux内核v2.6中的pthread与kthread</a></li>
<li><a href="https://blog.csdn.net/wwxy1995/article/details/109334092">操作系统基础知识用户态和内核态的区别</a></li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>goroutine</tag>
        <tag>用户态</tag>
        <tag>内核态</tag>
        <tag>线程</tag>
        <tag>协程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程/线程、同步/异步、阻塞/非阻塞</title>
    <url>/2021/05/19/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
    <content><![CDATA[<p>这篇文章我们将重点讨论 <strong>进程/线程、同步/异步、阻塞/非阻塞</strong>问题</p>
<span id="more"></span>

<blockquote>
<p>修改记录</p>
<ul>
<li>2021-5-26 修改进程和线程的相关概念 <a href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B">进程、线程</a></li>
</ul>
</blockquote>
<h1 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h1><p>在没有线程之前，进程是资源分配和调度的基本单位</p>
<p>在有线程之后,<strong>进程是资源分配的基本单位，线程是处理机调度的基本单位</strong></p>
<p><img src="/2021/05/19/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt="进程状态模型"></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>Windows系统中的一个基本概念，它包含着一个运行程序所需要的资源，<strong>进程可以包括一个或多个线程</strong>。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><strong>进程中的基本执行单元，是操作系统分配CPU时间的基本单位，一个进程可以包含若干个线程，在进程入口执行的第一个线程被视为这个进程的主线程。</strong></p>
<p>线程主要是由CPU寄存器、调用栈和线程本地存储器（Thread Local Storage，TLS）组成的。</p>
<ul>
<li><strong>CPU寄存器</strong>主要记录当前所执行线程的状态</li>
<li><strong>调用栈</strong>主要用于维护线程所调用到的内存与数据</li>
<li><strong>TLS</strong>主要用于存放线程的状态信息。</li>
</ul>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p><strong>进程和线程的主要差别在于它们是不同的操作系统资源管理方式</strong>。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。<strong>线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间</strong>，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<ol>
<li><p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</p>
</li>
<li><p>线程的划分尺度小于进程，使得多线程程序的并发性高。</p>
</li>
<li><p>另外，<strong>进程在执行过程中拥有独立的内存单元</strong>，而<strong>多个线程共享内存</strong>，从而极大地提高了程序的运行效率。</p>
</li>
<li><p>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
</li>
<li><p>从逻辑角度来看，<strong>多线程的意义在于一个应用程序中，有多个执行部分可以同时执行</strong>。但<strong>操作系统并没有将多个线程看做多个独立的应用来实现进程的调度和管理以及资源分配</strong>。这就是进程和线程的重要区别。</p>
</li>
</ol>
<h1 id="同步（Sync）和异步（Async）"><a href="#同步（Sync）和异步（Async）" class="headerlink" title="同步（Sync）和异步（Async）"></a>同步（Sync）和异步（Async）</h1><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>所谓同步，就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。</p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>异步与同步相对，当一个异步过程调用发出后，<strong>调用者在没有得到结果之前，就可以继续执行后续操作</strong>。当这个调用完成后，<strong>一般通过状态、通知和回调来通知调用者</strong>。对于异步调用，调用的返回并不受调用者控制。</p>
<p>对于通知调用者的三种方式，具体如下：</p>
<ul>
<li><p>状态</p>
<p>即<strong>监听被调用者的状态（轮询）</strong>，调用者需要每隔一定时间检查一次，效率会很低。</p>
</li>
<li><p>通知</p>
<p>当被调用者执行完成后，<strong>发出通知告知调用者</strong>，无需消耗太多性能。</p>
</li>
<li><p>回调</p>
<p>与通知类似，当被调用者执行完成后，会<strong>调用调用者提供的回调函数</strong>。</p>
</li>
</ul>
<h2 id="JavaScript中的异步"><a href="#JavaScript中的异步" class="headerlink" title="JavaScript中的异步"></a>JavaScript中的异步</h2><p>众所周知，js语言的一大特点就是单线程，那么它的异步是怎么实现的呢？</p>
<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>js中IO设备（输入输出设备）很慢(如Ajax操作从网络读取数据)，不得不等着结果出来，再往下执行。<br>JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，<strong>挂起处于等待中的任务，先运行排在后面的任务</strong>。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。<br>于是，所有任务可以分成两种，</p>
<ul>
<li>一种是<strong>同步任务（synchronous）</strong><br>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务</li>
<li>另一种是<strong>异步任务（asynchronous）</strong><br>异步任务指的是，不进入主线程，而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li>
</ul>
<p>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）</p>
<ol>
<li>所有同步任务都在主线程上执行，形成一个<strong>执行栈（execution context stack）</strong>。</li>
<li>主线程之外，还存在一个”<strong>任务队列”（task queue）</strong>。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li>
<li>一旦”<strong>执行栈</strong>“中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>
<li>主线程不断重复上面的第三步。</li>
</ol>
<p><img src="/2021/05/19/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E/%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.jpg" alt="异步执行过程.jpg"><br>只要主线程空了，就会去读取”任务队列”，这就是js的运行机制。这个过程会不断重复。</p>
<h3 id="事件和回调函数"><a href="#事件和回调函数" class="headerlink" title="事件和回调函数"></a>事件和回调函数</h3><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。</p>
<p>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。</p>
<h4 id="回调函数（callback）"><a href="#回调函数（callback）" class="headerlink" title="回调函数（callback）"></a>回调函数（callback）</h4><p>那些会被主线程挂起来的代码。异步任务必须指定回调函数，当<strong>主线程开始执行异步任务，就是执行对应的回调函数</strong>。</p>
<h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</p>
<p><img src="/2021/05/19/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E/evenloop.png" alt="evenloop"></p>
<p>上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种<strong>外部API</strong>，它们<strong>在”任务队列”中加入各种事件</strong>（click，load，done）。只要栈中的代码执行完毕，主线程就会去<strong>读取”任务队列”<strong>，</strong>依次执行那些事件所对应的回调函数</strong>。</p>
<p>执行栈中的代码（同步任务），总是在读取”任务队列”（异步任务）之前执行。请看下面这个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">req.open(<span class="string">&#x27;GET&#x27;</span>, url);    </span><br><span class="line">req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;    </span><br><span class="line">req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;    </span><br><span class="line">req.send();</span><br></pre></td></tr></table></figure>

<p>上面代码中的<code>req.send</code>方法是Ajax操作向服务器发送数据，它是一个异步任务，意味着只有当前脚本的所有代码执行完，系统才会去读取”任务队列”。所以，它与下面的写法等价。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">req.open(<span class="string">&#x27;GET&#x27;</span>, url);    </span><br><span class="line">req.send();</span><br><span class="line">req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;    </span><br><span class="line">req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;    </span><br></pre></td></tr></table></figure>

<p>也就是说，指定回调函数的部分（onload和onerror），在send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取”任务队列”。</p>
<h2 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别"></a>同步和异步的区别</h2><p>请求发出后，是否需要等待结果，才能继续执行其他操作。</p>
<h1 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h1><p>阻塞和非阻塞这两个概念与<strong>程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关</strong>。</p>
<p>阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong></p>
<p>阻塞调用是指调用结果返回之前，<strong>当前线程会被挂起</strong>。调用线程只有在得到结果之后才会返回。</p>
<p>非阻塞调用指在不能立刻得到结果之前，<strong>直接返回结果</strong>，使该调用不会阻塞当前线程。</p>
<p><strong>同步/异步 关注的是消息通知的机制</strong></p>
<p><strong>阻塞/非阻塞 关注的是程序（线程）等待消息通知时的状态。</strong></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.cnblogs.com/mhq-martin/p/9035640.html">15分钟读懂进程线程、同步异步、阻塞非阻塞、并发并行 - mhq_martin - 博客园 (cnblogs.com)</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈Event Loop</a></li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>进程</tag>
        <tag>JavaScript</tag>
        <tag>同步</tag>
        <tag>异步</tag>
        <tag>阻塞</tag>
        <tag>非阻塞</tag>
        <tag>even loop</tag>
      </tags>
  </entry>
</search>
