<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>I/O多路复用理解</title>
    <url>/2021/05/12/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>这篇文章我们将详细说明I/O多路复用的内容</p>
<span id="more"></span>

<blockquote>
<p>在了解I/O多路复用前，我们首先要了解 </p>
<ul>
<li><a href="/2021/05/19/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E">进程、线程</a></li>
<li><a href="/2021/05/19/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E">同步、异步</a></li>
<li><a href="/2021/05/19/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E">阻塞、非阻塞</a></li>
<li><a href="/2021/05/18/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-%E6%96%87%E4%BB%B6%E8%A1%A8%E9%A1%B9">文件描述符</a></li>
</ul>
</blockquote>
<h1 id="I-O的四种形式"><a href="#I-O的四种形式" class="headerlink" title="I/O的四种形式"></a>I/O的四种形式</h1><ul>
<li><p>同步阻塞形式</p>
</li>
<li><p>异步阻塞形式</p>
<blockquote>
<p>异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。</p>
</blockquote>
</li>
<li><p>同步非阻塞形式</p>
<blockquote>
<p>很多人会写阻塞的<code>read/write</code> 操作，但是别忘了可以对<code>fd</code>设置<code>O_NONBLOCK </code>标志位，这样就可以将同步操作变成非阻塞的了。</p>
</blockquote>
</li>
<li><p>异步非阻塞形式</p>
</li>
</ul>
<h1 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h1><p>要想客户端和服务器能在网络中通信，那必须得使用 Socket 编程，它是进程间通信里比较特别的方式，特别之处在于它是可以跨主机间通信。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>只使用一个进程来维护多个请求<br>一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做<strong>时分多路复用</strong>。</p>
<h2 id="TCP协议下的Socket"><a href="#TCP协议下的Socket" class="headerlink" title="TCP协议下的Socket"></a>TCP协议下的Socket</h2><p>TCP 协议的 Socket 程序的整个过程如下图：<br><img src="/2021/05/12/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%90%86%E8%A7%A3/socket%E5%85%A8%E8%BF%87%E7%A8%8B.png" alt="socket全过程"><br>有没有觉得读写 Socket 的方式，好像读写文件一样。</p>
<blockquote>
<p>基于 Linux 一切皆文件的理念，在内核中 Socket 也是以「文件」的形式存在的，也是有对应的文件描述符。<br>关于文件描述符的详细请看这里→<a href="/2021/05/18/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-%E6%96%87%E4%BB%B6%E8%A1%A8%E9%A1%B9">文件描述符/文件表项</a></p>
</blockquote>
<h2 id="select-poll"><a href="#select-poll" class="headerlink" title="select/poll"></a>select/poll</h2><p><code>select</code> 实现多路复用的方式是，将已连接的 Socket 都放到一个文件描述符集合，然后调用 select 函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过遍历文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。</p>
<p>所以，对于 select 这种方式，需要进行 <strong>2 次「遍历」</strong>文件描述符集合，一次是在内核态里，一个次是在用户态里 ，而且还会发生 <strong>2 次「拷贝」</strong>文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p>
<p><code>select</code>使用固定长度的 <code>BitsMap</code>，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 <code>FD_SETSIZE</code> 限制， 默认最大值为 <code>1024</code>，只能监听 <code>0~1023 </code>的文件描述符。</p>
<p>poll 不再用 <code>BitsMap</code> 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了<code>select</code>的文件描述符个数限制，当然<strong>还会受到系统文件描述符限制。</strong></p>
<p>但是 <code>poll </code>和 <code>select</code> 并没有太大的本质区别，都是使用「线性结构」存储进程关注的 <code>Socket </code>集合，因此都需要遍历文件描述符集合来找到可读或可写的 <code>Socket</code>，时间复杂度为 <code>O(n)</code>，而且也需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发数上来，性能的损耗会呈指数级增长。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//epoll_create 建立一个epoll对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;  </span><br><span class="line"><span class="comment">//epoll_ctl 向epoll对象中添加socket套接字；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">// epoll_wait 返回已经准备就绪事件的连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,<span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;  </span><br></pre></td></tr></table></figure>
<p>具体使用请看后面的<em>echo服务器示例</em></p>
<p>从下图你可以看到 <code>epoll</code> 相关的接口作用：</p>
<p><img src="/2021/05/12/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%90%86%E8%A7%A3/1616141449-ykDyCB-file_1616141448576.png" alt="1616141449-ykDyCB-file_1616141448576"></p>
<p>epoll 通过两个方面，很好解决了 select/poll 的问题。</p>
<p>第一点，epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删查一般时间复杂度是 <code>O(logn)</code>，通过对这棵黑红树进行操作，这样就不需要像 select/poll 每次操作时都传入整个 socket 集合，只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</p>
<p>第二点，epoll 使用事件驱动的机制，所有添加到epoll中的事件都会与<em>设备(如网卡)驱动程序**</em>建立回调关系<strong>，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做<code>ep_poll_callback</code>，它会把这样的事件放到上面的</strong>rdllist双向链表**中, 当用户调用<code>epoll_wait()</code>函数时，只会返回有事件发生的文件描述符的个数，不需要像 <code>select/poll</code> 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</p>
<p><img src="/2021/05/12/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%90%86%E8%A7%A3/epoll.png" alt="epoll"></p>
<p>epoll 支持两种事件触发模式，分别是<strong>边缘触发（<em>edge-triggered，ET</em>）</strong>和<strong>水平触发（<em>level-triggered，LT</em>）</strong>。</p>
<ul>
<li>水平触发：只要这个文件描述符还有数据可读，每次 <code>epoll_wait</code>都会返回它的事件，提醒用户程序去操作</li>
<li>边缘触发：当文件描述符上有新的I/O事件到来时，内核才会通知进程</li>
</ul>
<p>如果使用水平触发模式，当内核通知文件描述符可读写时，接下来还可以继续去检测它的状态，看它是否依然可读或可写。所以在收到通知后，没必要一次执行尽可能多的读写操作。</p>
<p>如果使用边缘触发模式，I/O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会循环从文件描述符读写数据，那么如果文件描述符是阻塞的，那这个一直读或一直写势必会在最后一次阻塞。所以，<strong>边缘触发模式一般和非阻塞 I/O 搭配使用</strong>，程序会一直执行 I/O 操作，直到系统调用（如 read 和 write）返回错误，错误类型为 <code>EAGAIN</code> 或<code> EWOULDBLOCK</code>。</p>
<p><img src="/2021/05/12/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%90%86%E8%A7%A3/%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F.png" alt="触发方式"></p>
<p>一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 <code>epoll_wait </code>的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。</p>
<p>select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。</p>
<p>另外，使用 I/O 多路复用时，最好搭配非阻塞 I/O 一起使用，Linux 手册关于 select 的内容中有如下说明：</p>
<blockquote>
<p>Under Linux, select() may report a socket file descriptor as “ready for reading”, while nevertheless a subsequent read blocks. This could for example happen when data has arrived but upon examination has wrong checksum and is discarded. There may be other circumstances in which a file descriptor is spuriously reported as ready. Thus it may be safer to use O_NONBLOCK on sockets that should not block.</p>
</blockquote>
<h3 id="为什么部分IO设备不需要CPU-题外话"><a href="#为什么部分IO设备不需要CPU-题外话" class="headerlink" title="为什么部分IO设备不需要CPU(题外话)"></a>为什么部分IO设备不需要CPU(题外话)</h3><p><code>字符设备</code>, 比如键盘, 打印机等, 还是得通过CPU的。<br><code>块设备</code>I/O模块增加DMA(Direct Memory Access 直接存储器)控制器. DMA控制器类似于一个小的CPU, 有自己的寄存器(记录主存地址和取到的字的count等). CPU可以发起一个DMA请求, 传入读写操作类型, 相关I/O设备地址, 内存的起始地址, 要操作的字数.然<br>后DMA就可以获取总线的控制权, 将一大块内存和外部I/O读入或写出.等操作完成后, 再通知CPU. 释放总线控制权。</p>
<h2 id="echo服务器"><a href="#echo服务器" class="headerlink" title="echo服务器"></a>echo服务器</h2><p>我们通过一个回射服务器程序来展示<code>epoll</code>的标准用法。先简要介绍<code>epoll</code>的接口。主要由三个函数组成：</p>
<ul>
<li><code>epoll_create</code>创建新的<code>epoll</code>实例，一般使用最新的<code>epoll_create1</code>调用</li>
<li><code>epoll_ctl</code>管理感兴趣的文件描述符和相应事件</li>
<li><code>epoll_wait</code>返回就绪的文件描述符，然后对它们进行I/O操作</li>
</ul>
<p>程序的主要流程如下：</p>
<ol>
<li>创建一个监听套接字<code>lfd</code>，调用<code>set_nonblocking</code>函数将其设置为非阻塞</li>
<li>调用<code>epoll_create1</code>函数创建一个<code>epoll</code>实例，对应的文件描述符为<code>epfd</code></li>
<li>将监听套接字<code>lfd</code>加入到<code>epfd</code>的事件列表<code>event</code>中，监听的事件为<code>EPOLLIN</code></li>
<li>进入死循环，<code>epoll_wait</code>函数一直阻塞，直到有事件发生。事件信息保存在<code>evlist</code>中</li>
<li>检查文件描述符及其事件：<ul>
<li>如果是发生在监听套接字<code>lfd</code>上的事件，则收到了一个客户请求，将返回的连接套接字<code>cfd</code>设置为边沿触发（EPOLLET）模式，加入到事件列表<code>event</code>中</li>
<li>如果是连接套接字<code>cfd</code>上发生的事件，对<code>EPOLLIN</code>事件，调用<code>do_echo</code>函数执行回射操作；对<code>EPOLLERR</code>或<code>EPOLLHUP</code>事件，则关闭描述符</li>
</ul>
</li>
</ol>
<p>全部代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT_NUM   40713</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">char</span> *msg)</span> </span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 fd 设置为非阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_nonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">if</span> ((flags = fcntl(fd, F_GETFL, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;ERROR fcntl F_GETFL&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == <span class="number">-1</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;ERROR fcntl F_SETFL&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_echo</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c, buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = read(fd, &amp;c, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            error(<span class="string">&quot;ERROR read from client&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buf[cnt++] = c;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(fd, buf, cnt) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                error(<span class="string">&quot;ERROR write to client&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> epfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">evlist</span>;</span></span><br><span class="line">    </span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(PORT_NUM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;ERROR socket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    set_nonblocking(lfd);</span><br><span class="line">    <span class="keyword">if</span> (bind(lfd, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;ERROR bind&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(lfd, <span class="number">16</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;ERROR listen&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个epoll实例，对应的文件描述符为epfd</span></span><br><span class="line">    epfd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (epfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ERROR epoll_create1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将监听套接字 lfd 加入到 epfd 的事件列表 event 中，监听的事件为`EPOLLIN`</span></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = lfd;</span><br><span class="line">    <span class="comment">//对事件进行监听</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;event) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;ERROR epoll_ctl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    evlist = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct epoll_event)*MAX_EVENTS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> cfd;</span><br><span class="line">        <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">        <span class="comment">//epoll_wait函数一直阻塞，直到有事件发生。事件信息保存在evlist中</span></span><br><span class="line">        <span class="comment">//-1表示如果取不到东西，就无限等待</span></span><br><span class="line">        <span class="comment">//0代表立马返回</span></span><br><span class="line">        <span class="comment">//它会把传入的时间转为绝对时间</span></span><br><span class="line">        <span class="keyword">int</span> ready = epoll_wait(epfd, evlist, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ready == <span class="number">-1</span>) &#123;</span><br><span class="line">            error(<span class="string">&quot;ERROR epoll_wait&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ready; i++) &#123;</span><br><span class="line">            <span class="comment">//如果是 套接字lfd 就获取</span></span><br><span class="line">            <span class="keyword">if</span> (evlist[i].data.fd == lfd) &#123;</span><br><span class="line">                cfd = accept(lfd, (struct sockaddr *)&amp;client_addr, &amp;len);</span><br><span class="line">                <span class="keyword">if</span> (cfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;ERROR accept&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                set_nonblocking(cfd);</span><br><span class="line">                event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line">                event.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;event);</span><br><span class="line">                <span class="comment">//如果是可读事件发生,进行操作</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (evlist[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">                cfd = evlist[i].data.fd;</span><br><span class="line">                do_echo(cfd);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (evlist[i].events &amp; (EPOLLHUP | EPOLLERR)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (close(evlist[i].data.fd) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    error(<span class="string">&quot;ERROR close&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://leetcode-cn.com/circle/discuss/ylV7i6/">分享｜再也不怕被问 I/O 多路复用 | 技术人求职记 - 力扣（LeetCode） (leetcode-cn.com)</a></li>
<li><a href="https://panqiincs.me/2015/08/01/io-multiplexing-with-epoll/">I/O多路复用之epoll | 辛未羊的网络日志 (panqiincs.me)</a></li>
<li><a href="https://blog.csdn.net/daaikuaichuan/article/details/83862311?ivk_sa=1024320u">epoll原理详解及epoll反应堆模型</a></li>
<li><a href="https://journey-c.github.io/io-multiplexing/#5-epoll">Linux的I/O多路复用机制 - Journey-C</a></li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>I/O</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>go并发模型研究</title>
    <url>/2021/05/19/go%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>go 实现的是 CSP (Communicating Sequential Process，通讯顺序进程) 模型</p>
<span id="more"></span>

<h1 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h1><p>CSP (Communicating Sequential Process，通讯顺序进程) 模型是上个世纪七十年代提出的,<strong>不同于传统的多线程通过共享内存来通信，CSP 讲究的是“_以通信的方式来共享内存_”</strong>。用于描述两个独立的并发实体通过**共享的通讯 channel(管道)**进行通信的并发模型。 CSP 中<code>channel</code>是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的<code>channel</code>。</p>
<p>Golang 就是借用 CSP 模型的一些概念为之实现并发进行理论支持，其实从实际上出发，go 语言并没有完全实现了 CSP 模型的所有理论，仅仅是借用了 <code>process</code>和<code>channel</code>这两个概念。**<code>process</code>是在 go 语言上的表现就是 <code>goroutine</code> 是实际并发执行的实体<strong>，每个</strong>实体之间是通过<code>channel</code>通讯来实现数据共享**。</p>
<h1 id="chanel"><a href="#chanel" class="headerlink" title="chanel"></a>chanel</h1><p>Golang 中<code>channel</code>是被单独创建并且可以在<code>goroutine</code>并发实体之间传递，它的通信模式类似于 <code>boss-worker</code> 模式的，<strong>一个实体通过将消息发送到<code>channel</code> 中，然后又监听这个 <code>channel</code> 的实体处理</strong>，两个实体之间是匿名的，这个就实现实体中间的解耦，其中 <code>channel</code> 是同步的,一个消息被发送到 <code>channel</code> 中，最终是一定要被另外的实体消费掉的，在实现原理上其实类似一个阻塞的消息队列。</p>
<h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h1><p><code>Goroutine</code>是 Golang 实际并发执行的实体，它底层是使用协程(<code>coroutine</code>)实现并发，<code>coroutine</code>是一种运行在用户态的用户线程，类似于<code>greenthread</code>，go 底层选择使用<code>coroutine</code>的出发点是因为，它具有以下特点：</p>
<ul>
<li>用户空间 避免了内核态和用户态的切换导致的成本。</li>
<li>可以由语言和框架层进行调度。</li>
<li>更小的栈空间允许创建大量的实例。</li>
</ul>
<p>更多请看 →<a href="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3">线程/协程详解</a></p>
<h2 id="Goroutine-是异步执行的"><a href="#Goroutine-是异步执行的" class="headerlink" title="Goroutine 是异步执行的"></a>Goroutine 是异步执行的</h2><p>有的时候为了防止在结束 main 函数的时候结束掉<code>Goroutine</code>，所以需要同步等待，可以使用一下三种方式：</p>
<ul>
<li><p><strong>channel</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)    无缓冲的channel由于没有缓冲发送和接收需要同步.</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>) 有缓冲channel不要求发送和接收操作同步.</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">&quot;start working&quot;</span>)</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; &#125;()</span><br><span class="line">&lt;-ch <span class="comment">//会阻塞直到协程完成</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>sync.WaitGroup</strong></p>
<blockquote>
<p>在 sync 包中，提供了 WaitGroup ，它会等待它收集的所有 goroutine 任务全部完成。在 WaitGroup 里主要有三个方法:<br><strong>Add</strong>, 可以添加或减少 goroutine 的数量.<br><strong>Done</strong>, 相当于 Add(-1).<br><strong>Wait</strong>, 执行后会堵塞主线程，直到 WaitGroup 里的值减至 0.</p>
</blockquote>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">var</span> urls = []<span class="keyword">string</span>&#123;<span class="string">&quot;http://www.golang.org/&quot;</span>, <span class="string">&quot;http://www.google.com/&quot;</span>,&#125;</span><br><span class="line">	<span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(url <span class="keyword">string</span>)</span></span> &#123; <span class="keyword">defer</span> wg.Done()</span><br><span class="line">		http.Get(url) &#125;(url)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>context</strong></p>
<blockquote>
<p>context 包主要是用来处理多个 goroutine 之间共享数据，及多个 goroutine 的管理。context 包的核心是 struct Context，接口声明如下：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Context carries a deadline, cancelation signal, and request-scoped values</span></span><br><span class="line"><span class="comment">// across API boundaries. Its methods are safe for simultaneous use by multiple</span></span><br><span class="line"><span class="comment">// goroutines.</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Done 返回一个只能接受数据的channel类型，当该context关闭或者超时时间到了的时候，</span></span><br><span class="line">	<span class="comment">//该channel就会有一个取消信号</span></span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Err 在Done() 之后，返回context 取消的原因。</span></span><br><span class="line">	Err() error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Deadline 设置该context cancel的时间点</span></span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Value 允许 Context 对象携带request作用域的数据，该数据必须是线程安全的。</span></span><br><span class="line">	Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Context 对象是线程安全的，你可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。</p>
</li>
</ul>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="双协程交替打印-1-10"><a href="#双协程交替打印-1-10" class="headerlink" title="双协程交替打印 1-10"></a>双协程交替打印 1-10</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双协程交替打印1-10</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= <span class="number">10</span>; i += <span class="number">2</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;A:&quot;</span>, &lt;-a) <span class="comment">//等待打印</span></span><br><span class="line">			a &lt;- i                 <span class="comment">//传入，下面的协程接受</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(exit)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">9</span>; i += <span class="number">2</span> &#123;</span><br><span class="line">			a &lt;- i                 <span class="comment">//传入，上面的协程接受</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;B:&quot;</span>, &lt;-a) <span class="comment">//等待打印</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	&lt;-exit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>goroutine</tag>
        <tag>go并发模型</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划算法思路</title>
    <url>/2021/05/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<p>在这片文章中，我们总结了动态规划的基本思路，大致就分为三种</p>
<span id="more"></span>

<p>此文章整理自<code>CyC</code>大佬，github地址：</p>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md#leetcode-%E9%A2%98%E8%A7%A3---%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md#leetcode-%E9%A2%98%E8%A7%A3---%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92</a></p>
<h1 id="常见的背包问题"><a href="#常见的背包问题" class="headerlink" title="常见的背包问题"></a>常见的背包问题</h1><ul>
<li>组合问题</li>
<li>True、False问题</li>
<li>最大最小问题</li>
</ul>
<h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/description/" title="377. 组合总和 Ⅳ">377. 组合总和 Ⅳ</a></p>
<p><a href="https://leetcode-cn.com/problems/target-sum/description/" title="494. 目标和">494. 目标和</a></p>
<p><a href="https://leetcode-cn.com/problems/coin-change-2/description/" title="518. 零钱兑换 II">518. 零钱兑换 II</a></p>
<h2 id="True、False问题"><a href="#True、False问题" class="headerlink" title="True、False问题"></a>True、False问题</h2><p><a href="https://leetcode-cn.com/problems/word-break/" title="139. 单词拆分">139. 单词拆分</a></p>
<p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/description/" title="416. 分割等和子集">416. 分割等和子集</a></p>
<h2 id="最大最小问题"><a href="#最大最小问题" class="headerlink" title="最大最小问题"></a>最大最小问题</h2><p><a href="https://leetcode-cn.com/problems/ones-and-zeroes/description/" title="474. 一和零">474. 一和零</a></p>
<p><a href="https://leetcode-cn.com/problems/coin-change/description/" title="322. 零钱兑换">322. 零钱兑换</a></p>
<h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><h2 id="组合问题公式"><a href="#组合问题公式" class="headerlink" title="组合问题公式"></a>组合问题公式</h2><pre><code>dp[i] += dp[i-num]
</code></pre>
<h2 id="True、False问题公式"><a href="#True、False问题公式" class="headerlink" title="True、False问题公式"></a>True、False问题公式</h2><pre><code>dp[i] = dp[i] or dp[i-num]
</code></pre>
<h2 id="最大最小问题公式"><a href="#最大最小问题公式" class="headerlink" title="最大最小问题公式"></a>最大最小问题公式</h2><pre><code>dp[i] = min(dp[i], dp[i-num]+1)或者dp[i] = max(dp[i], dp[i-num]+1)
</code></pre>
<p>以上三组公式是解决对应问题的核心公式。</p>
<h1 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h1><p>当然拿到问题后，需要做到以下几个步骤：</p>
<ol>
<li>分析是否为背包问题。</li>
<li>是以上三种背包问题中的哪一种。</li>
<li>是0-1背包问题还是完全背包问题。也就是题目给的nums数组中的元素是否可以重复使用。</li>
<li>如果是<strong>组合问题</strong>，<strong>是否需要考虑元素之间的顺序</strong>。需要考虑顺序有顺序的解法，不需要考虑顺序又有对应的解法。</li>
</ol>
<h2 id="背包问题特征"><a href="#背包问题特征" class="headerlink" title="背包问题特征"></a>背包问题特征</h2><p>给定一个<code>target</code>，<code>target</code>可以是数字也可以是字符串，再给定一个数组<code>nums</code>，<code>nums</code>中装的可能是数字，也可能是字符串，<strong>问</strong>：能否使用<code>nums</code>中的元素做各种排列组合得到<code>target</code>。</p>
<h1 id="背包问题技巧"><a href="#背包问题技巧" class="headerlink" title="背包问题技巧"></a>背包问题技巧</h1><p>如果是<strong>0-1背包</strong>，即数组中的<strong>元素不可重复使用</strong>，<strong>nums放在外循环</strong>，<strong>target在内循环</strong>，且<strong>内循环倒序</strong>；</p>
<pre><code>for num in nums:
    for i in range(target, nums-1, -1):
</code></pre>
<p>如果是<strong>完全背包</strong>，即数组中的<strong>元素可重复使用</strong>，<strong>nums放在外循环</strong>，<strong>target在内循环</strong>。且<strong>内循环正序</strong>。</p>
<pre><code>for num in nums:
    for i in range(nums, target+1):
</code></pre>
<p>如果组合问题需<strong>考虑元素之间的顺序</strong>，需将<strong>target放在外循环</strong>，将<strong>nums放在内循环</strong>。</p>
<pre><code>for i in range(1, target+1):
    for num in nums:
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>思路</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>文件描述符/文件表项</title>
    <url>/2021/05/18/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-%E6%96%87%E4%BB%B6%E8%A1%A8%E9%A1%B9/</url>
    <content><![CDATA[<p>从Linux的层次角度来说，在用户空间是存在这样的概念的，这个概念是存在内核空间的，而且是针对打开的文件的！</p>
<span id="more"></span>

<h1 id="进程表"><a href="#进程表" class="headerlink" title="进程表"></a>进程表</h1><p>也称进程控制块PCB，由结构<code>task_struct</code>所定义的数据结构。<code>task_struct</code>结构体专门用于存放进程在运行过程中，所涉及到的所有与进程相关的信息。这个结构体的成员项非常多，多达近300个。其中，文件描述符表就被包含在了<code>task_struct</code>结构体当中。在进程运行结束后，进程表所占用的内存空间，会被释放。</p>
<p>打开一个文件的内核数据结构图</p>
<p><img src="/2021/05/18/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-%E6%96%87%E4%BB%B6%E8%A1%A8%E9%A1%B9/%E8%BF%9B%E7%A8%8B%E8%A1%A8.jpg" alt="关系图"></p>
<h1 id="三种数据结构"><a href="#三种数据结构" class="headerlink" title="三种数据结构"></a>三种数据结构</h1><blockquote>
<p>从Linux的层次角度来说，在用户空间是存在这样的概念的，这个概念是存在内核空间的，而且是针对打开的文件的！<br>内核用三种数据结构来描述一个打开的文件。</p>
</blockquote>
<h2 id="文件描述符表："><a href="#文件描述符表：" class="headerlink" title="文件描述符表："></a>文件描述符表：</h2><p><code>open</code>打开文件后，会在进程的<code>task_struct</code>结构体中，创建相应的结构体，用以存放打开文件的相关信息。对文件进行读写等操作时，会用到这些信息，这个数据结构就是我们要讲的<code>文件描述符表</code>。<br>每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的文件描述符表项指向<code>文件表</code>中的一个表项。</p>
<h2 id="文件表"><a href="#文件表" class="headerlink" title="文件表"></a>文件表</h2><p>所有”打开的文件”的集合!<br>每个磁盘文件在打开时都会在内核中建立一个<strong>文件表项</strong>，内核为所有打开文件维持一张文件表。<br>每个<strong>文件表项</strong>包括：</p>
<ul>
<li>文件状态标志：读、写、添写、同步、非阻塞等</li>
<li>当前文件偏移量</li>
<li>指向该文件v节点表项的指针</li>
</ul>
<h3 id="文件状态标志"><a href="#文件状态标志" class="headerlink" title="文件状态标志"></a>文件状态标志</h3><p>文件状态标志就是open文件时指定的<code>O_RDONLY</code>、<code>O_WRONLY</code>、<code>O_RDWR</code>等操作权限。open打开文件成功后，就会将文件状态标志保存到文件表中。在对文件执行操作时，会先检查文件状态标志，看看有没有操作权限，然后再去操作文件。</p>
<h3 id="文件偏移量"><a href="#文件偏移量" class="headerlink" title="文件偏移量"></a>文件偏移量</h3><p>文件当前读写位置与文件开始位置的距离（字节数）。</p>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>在<code>read</code>、<code>write</code>等操作文件时，会根据底层具体情况的不同，调用不同的函数来实现读写。在V节点里面保存了这些不同函数的函数指针，方便调用。</p>
<h2 id="v-node"><a href="#v-node" class="headerlink" title="v-node"></a>v-node</h2><p><code>v-node</code> 在(<code>v-node table</code>) 。同文件表一样，所有的进程共享这张<code>v-node表</code>。<br>每个打开文件(或设备)都有个v节点结构。<br>v节点包含：</p>
<ul>
<li>文件类型</li>
<li>对此文件进行各种操作的函数指针。 </li>
</ul>
<p>对于大多数文件，v节点还包含了该文件的i节点（索引节点）。</p>
<p>i节点包含：</p>
<ul>
<li>文件的所有者</li>
<li>文件长度</li>
<li>文件所在设备</li>
<li>指向文件实际在磁盘上所在位置的指针。</li>
</ul>
<h3 id="文件长度"><a href="#文件长度" class="headerlink" title="文件长度"></a>文件长度</h3><p>记录了文件当前的长度，文件长度是动态更新的。</p>
<p><strong>注</strong>：</p>
<ol>
<li>在文件表或者v索引节点中都有索引计数 (即当前指向该表项的描述符表项数)，引用计数为0的时候就可以收回此表项</li>
<li>fork后父子进程各自的每一个打开的文件描述符共享同一个文件表项</li>
</ol>
<p>参考地址：<br><a href="http://emb.hqyj.com/Column/4458.html">什么是＂文件表项＂</a><br><a href="https://zhuanlan.zhihu.com/p/56251739">进程表和文件描述表</a><br><a href="https://www.cnblogs.com/tianzeng/p/11037229.html">文件描述符标志/文件表项</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>文件描述符</tag>
        <tag>文件表项</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>线程/协程详解</title>
    <url>/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>之前一篇文章简单介绍了进程和线程，这篇文章我们将介绍一下轻量级进程、线程和协程</p>
<span id="more"></span>
<p>在说这写概念之前，我们需要了解一下什么是<code>内核态</code>和<code>用户态</code></p>
<h1 id="内核态-用户态"><a href="#内核态-用户态" class="headerlink" title="内核态/用户态"></a>内核态/用户态</h1><p>由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 :<strong>用户态</strong> 和 <strong>内核态</strong></p>
<ul>
<li><strong>内核态</strong>: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡。CPU也可以将自己从一个程序切换到另一个程序</li>
<li><strong>用户态</strong>: 只能受限的访问内存, 且不允许访问外围设备。 占用CPU的能力被剥夺, CPU资源可以被其他程序获取</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>用户空间中的代码被限制了只能使用一个局部的内存空间，我们说这些程序在<strong>用户态（User Mode）</strong> 执行。<br>内核空间中的代码可以访问所有内存，我们称这些程序在<strong>内核态（Kernal Mode）</strong> 执行。</p>
<h2 id="如何切换"><a href="#如何切换" class="headerlink" title="如何切换"></a>如何切换</h2><p>所有用户程序都是运行在用户态的, 但是有时候程序确实需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等. 而唯一可以做这些事情的就是操作系统, 所以此时程序就需要先操作系统请求以程序的名义来执行这些操作.</p>
<p>这时需要一个这样的机制: 用户态程序切换到内核态, 但是不能控制在内核态中执行的指令</p>
<p>这种机制叫<strong>系统调用</strong>, 在CPU中的实现称之为<strong>陷阱指令(Trap Instruction)</strong></p>
<p>他们的工作流程如下:</p>
<ol>
<li>用户态程序将一些数据值放在寄存器中, 或者使用参数创建一个堆栈(stack frame), 以此表明需要操作系统提供的服务.</li>
<li>用户态程序执行陷阱指令</li>
<li>CPU切换到内核态, 并跳到位于内存指定位置的指令, 这些指令是操作系统的一部分, 他们具有内存保护, 不可被用户态程序访问</li>
<li>这些指令称之为陷阱(trap)或者系统调用处理器(system call handler). 他们会读取程序放入内存的数据参数, 并执行程序请求的服务</li>
<li>系统调用完成后, 操作系统会重置CPU为用户态并返回系统调用的结果</li>
</ol>
<h3 id="切换方式"><a href="#切换方式" class="headerlink" title="切换方式"></a>切换方式</h3><ul>
<li><p>系统调用<br>这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的<strong>一个中断来实现</strong>，例如Linux的int 80h中断。</p>
</li>
<li><p>异常<br>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
</li>
<li><p>外围设备的中断<br>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
</li>
</ul>
<p>这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。</p>
<h1 id="线程-协程"><a href="#线程-协程" class="headerlink" title="线程/协程"></a>线程/协程</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><blockquote>
<p>内核通过操纵调度器（Thread Scheduler）对内核线程进行调度，并负责将线程的任务映射到各个处理器上</p>
</blockquote>
<p>每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情。支持多线程的内核就叫做多线程内核（Multi-Threads Kernel）。</p>
<p>线程分为用户态线程和内核态线程</p>
<h3 id="用户态线程"><a href="#用户态线程" class="headerlink" title="用户态线程"></a>用户态线程</h3><p>用户态线程也称作用户级线程（User Level Thread）。操作系统内核并不知道它的存在，它完全是在用户空间中创建。<br>而这里的用户线程指的是<strong>完全建立在用户空间的线程库</strong>，用户线程的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。因此这种线程的操作是极其快速的且低消耗的。</p>
<p>用户级线程有很多<strong>优势</strong>：</p>
<ul>
<li><strong>管理开销小</strong>：创建、销毁不需要系统调用。</li>
<li><strong>切换成本低</strong>：用户空间程序可以自己维护，不需要走操作系统调度。</li>
</ul>
<p>但是这种线程也有很多的<strong>缺点</strong>：</p>
<ul>
<li><strong>与内核协作成本高</strong>：比如这种线程完全是用户空间程序在管理，当它进行 I/O 的时候，无法利用到内核的优势，需要频繁进行用户态到内核态的切换。</li>
<li><strong>线程间协作成本高</strong>：设想两个线程需要通信，通信需要 I/O，I/O 需要系统调用，因此用户态线程需要支付额外的系统调用成本。</li>
<li><strong>无法利用多核优势</strong>(N:1模型中)：比如操作系统调度的仍然是这个线程所属的进程，所以无论每次一个进程有多少用户态的线程，都只能并发执行一个线程，因此一个进程的多个线程无法利用多核的优势。</li>
<li><strong>操作系统无法针对线程调度进行优化</strong>：当一个进程的一个用户态线程阻塞（Block）了，操作系统无法及时发现和处理阻塞问题，它不会更换执行其他线程，从而造成资源浪费。</li>
</ul>
<h3 id="内核态线程"><a href="#内核态线程" class="headerlink" title="内核态线程"></a>内核态线程</h3><p>内核态线程也称作内核级线程（Kernel Level Thread）。这种线程执行在内核态，可以通过系统调用创造一个内核级线程。</p>
<p>内核级线程有很多<strong>优势</strong>：</p>
<ul>
<li><strong>可以利用多核 CPU 优势</strong>：内核拥有较高权限，因此可以在多个 CPU 核心上执行内核线程。</li>
<li><strong>操作系统级优化</strong>：内核中的线程操作 I/O 不需要进行系统调用；一个内核线程阻塞了，可以立即让另一个执行。</li>
</ul>
<p>当然内核线程也有一些<strong>缺点</strong>：</p>
<ul>
<li><strong>创建成本高</strong>：创建的时候需要系统调用，也就是切换到内核态。</li>
<li><strong>扩展性差</strong>：由一个内核程序管理，不可能数量太多。</li>
<li><strong>切换成本较高</strong>：切换的时候，也同样存在需要内核操作，需要切换内核态。</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>用户态线程调度完全由<strong>进程</strong>负责，通常就是由进程的<strong>主线程</strong>负责。相当于进程主线程的延展，使用的是操作系统分配给进程主线程的时间片段。内核线程由<strong>内核维护</strong>，由操作系统调度。</p>
<p>用户态线程无法跨核心，一个进程的多个用户态线程<strong>不能并发</strong>，<strong>阻塞一个用户态线程会导致进程的主线程阻塞，直接交出执行权限</strong>。这些都是用户态线程的劣势。<br><strong>内核线程可以独立执行，操作系统会分配<em>时间片段</em></strong>。因此内核态线程更完整，也称作轻量级进程。内核态线程创建成本高，切换成本高，创建太多还会给调度算法增加压力，因此不会太多。</p>
<h3 id="三种线程模型"><a href="#三种线程模型" class="headerlink" title="三种线程模型"></a>三种线程模型</h3><p>实际操作中，往往结合两者优势，将用户态线程附着在内核态线程中执行。</p>
<ul>
<li><strong>N:1模型</strong><br><strong>多个用户空间线程在1个内核空间线程上运行</strong>。优势是<strong>上下文切换非常快</strong>，因为只有一个内核线程，用户线程不需要频繁系统调用，但是<strong>无法利用多核系统的优点</strong>。</li>
</ul>
<p><img src="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/%E5%A4%9A%E5%AF%B9%E4%B8%80.png" alt="多对一.png"></p>
<ul>
<li><strong>1:1模型</strong>[pthread线程库–NPTL(Native POSIX Threading Library)]<br><strong>1个内核空间线程运行一个用户空间线程</strong>。这种<strong>充分利用了多核系统的优势</strong>但是<strong>上下文切换非常慢</strong>，因为每一次调度都会在用户态和内核态之间切换，而且用<strong>户线程数量受到限制</strong>。POSIX线程模型(pthread)就是这么做的。</li>
</ul>
<p><img src="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/%E4%B8%80%E5%AF%B9%E4%B8%80.png" alt="一对一.png"></p>
<ul>
<li><strong>M:N模型</strong><br><strong>内核开启多个内核线程，一个内核空间线程对应多个用户空间线程</strong>。效率非常高，但是管理复杂。</li>
</ul>
<p><img src="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/%E5%A4%9A%E5%AF%B9%E5%A4%9A.png" alt="多对多.png"></p>
<h3 id="轻量级进程（Light-Weight-Process-LWP）"><a href="#轻量级进程（Light-Weight-Process-LWP）" class="headerlink" title="轻量级进程（Light Weight Process LWP）"></a>轻量级进程（Light Weight Process LWP）</h3><blockquote>
<p>在实际程序中我们一般不直接使用内核线程，用户线程与内核线程之间需要一种中间数据结构，它由内核支持且是内核线程的高级抽象，这个高级接口被称为轻量级进程（Light Weight Process）</p>
</blockquote>
<p>轻量级进程就是我们通常意义上所讲的线程，当然也属于用户线程；由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1:1的关系称为一对一的线程模型。</p>
<p>LWP虽然本质上属于用户线程，但LWP线程库是建立在内核之上的，LWP的许多操作都要进行系统调用，因此效率不高。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93.png" alt="线程调度模型总结.png"></p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><blockquote>
<p>本文将以<code>golang</code>中的协程为例展开</p>
</blockquote>
<p>对于进程、线程，都是有内核进行调度，有CPU时间片的概念，进行<strong>抢占式调度</strong>。<br>协程可以理解为<strong>用户态的轻量级的非抢占式的线程</strong>。适用于IO密集型。</p>
<p>协程，又称微线程，纤程。英文名Coroutine。协程的调用有点类似子程序，如程序A调用了子程序B，子程序B调用了子程序C，当子程序C结束了返回子程序B继续执行之后的逻辑，当子程序B运行结束了返回程序A，直到程序A运行结束。但是和子程序相比，<strong>协程有挂起的概念，协程可以挂起跳转执行其他协程，合适的时机再跳转回来</strong>。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>用户态</strong>:协程是在用户态实现调度。</li>
<li><strong>轻量级</strong>:协程不用内核调度，不用再内核态与用户态之间切换。</li>
<li><strong>非抢占</strong>:协程是由用户自己实现调度，协程自己主动交出CPU的。</li>
</ul>
<h3 id="go的协程调度原理"><a href="#go的协程调度原理" class="headerlink" title="go的协程调度原理"></a>go的协程调度原理</h3><p>go中的<code>goroutine</code>本质上就是协程，但是<strong>完全运行在用户态</strong>，借鉴了M:N模型。如下图<br><img src="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/gmp.jpg" alt="gmp.jpg"></p>
<p>相比其他语言，golang采用了GMP模型管理协程，更加高效，但是管理非常复杂。</p>
<ul>
<li>M：指的是<code>Machine</code>,一个M直接关联了一个内核线程。由操作系统管理。</li>
<li>G：指的是<code>goroutine</code>,其实本质上也是一种轻量级的线程。包括了<strong>调用栈</strong>，重要的<strong>调度信息</strong>，例如<code>channel</code>等。</li>
<li>P：指的是<code>Processor</code>，代表了<code>M</code>所需的上下文环境，也是处理用户级代码逻辑的处理器，它负责衔接<code>M</code>和<code>G</code>的调度上下文，将等待执行的<code>G</code>与<code>M</code>对接。</li>
</ul>
<h3 id="G-M-P三者的关系与特点"><a href="#G-M-P三者的关系与特点" class="headerlink" title="G-M-P三者的关系与特点"></a>G-M-P三者的关系与特点</h3><ul>
<li><code>P</code>的个数取决于设置的<code>GOMAXPROCS</code>,<strong><code>P</code>其实限定了<code>golang</code>调度其的最大并发度</strong>。go新版本默认使用最大内核数，比如你有8核处理器，那么P的数量就是8</li>
<li><code>M</code>的数量和<code>P</code>不一定匹配，可以设置很多<code>M</code>，**<code>M</code>和<code>P</code>绑定后才可运行和对G进行调度**，多余的<code>M</code>处于休眠状态</li>
<li><code>p</code>包含一个<strong>LRQ（Local Run Queue）本地运行队列</strong>，这里面保存着<strong>P需要执行的协程G的队列</strong><br>除了每个P自身保存的G的队列外，<strong>调度器还拥有一个全局的G队列GRQ（Global Run Queue）</strong>，这个队列存储的是<strong>所有未分配的协程G</strong>。</li>
</ul>
<p>单核主机下的协程运行图：<br><img src="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/2.jpg" alt="2.jpg"><br>红色部分表示挂起和休眠，黄色部分表示准备就绪等待运行，绿色部分表示正在运行。</p>
<hr>
<p>单核主机只有一个处理器P，但是系统初始化了两个线程M0和M1，处理器P优先绑定了M0线程，M1进入休眠状态。<br>P的LRQ队列里有G1,G2,G3等待处理。P目前正在处理G0,全局等待队列GRQ里保存着G4,G5，表示这两个协程还未分配给P。<br>如果G0在短时间内处理完，P就会从LRQ中取出G1继续处理。并且将GRQ全局队列中的部分协程加入LRQ中。<br><img src="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/3.jpg" alt="3.jpg"></p>
<hr>
<p>假设现在G1处理速度很慢，系统就会让M0线程休眠，挂起协程G1，唤醒线程M1进行处理其他的协程。这里M1会将M0未处理的协程取走处理。<br><img src="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/4.jpg" alt="4.jpg"></p>
<hr>
<p>等到M1协程队列中所有协程处理完再次唤醒M0，或者M1处理某个协程时间较长被挂起，M0也会被唤醒。</p>
<hr>
<p>上面的讨论是单核主机情况，如果是多核的，就会运行多个P和M，如图<br><img src="/2021/05/20/%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E8%AF%A6%E8%A7%A3/5.jpg" alt="5.jpg"></p>
<p>M0和M1分别运行在不同的内核中，M0处理G1,G2,G3，M1处理G4,G5,G6。</p>
<blockquote>
<p><strong>有人会问，当M0处理完所有的协程，而M1还未处理完，系统会如何做呢？</strong><br>  M0会取走M1的一半数量未处理的协程。</p>
</blockquote>
<p>golang协程设计非常优秀，一方面极大的利用了内核线程和处理器资源，另一方面每个处理器的LRQ队列的<strong>协程都处于用户态，这些协程的处理和挂起操作都是用户态的，协程切换开销非常小</strong>。相比其他语言的线程设计，更加轻量和高效。</p>
<h1 id="Linux使用的线程库"><a href="#Linux使用的线程库" class="headerlink" title="Linux使用的线程库"></a>Linux使用的线程库</h1><p><code>LinuxThreads</code>是<strong>用户空间的线程库</strong>，所采用的是<strong>线程-进程1对1模型(即一个用户线程对应一个轻量级进程，而一个轻量级进程对应一个特定的内核线程</strong>)，将线程的调度等同于进程的调度，调度交由内核完成，而线程的创建、同步、销毁由核外线程库完成（LinuxThtreads已绑定到 GLIBC中发行）。</p>
<h1 id="参考地址："><a href="#参考地址：" class="headerlink" title="参考地址："></a>参考地址：</h1><p><a href="https://www.cnblogs.com/shangxiaofei/p/5567776.html">多线程之：用户态和内核态的区别</a><br><a href="https://blog.csdn.net/gatieme/article/details/51481863">内核线程、轻量级进程、用户线程三种线程概念解惑（线程≠轻量级进程）</a><br><a href="https://blog.csdn.net/m0_50654102/article/details/116065035">用户态线程和内核态线程有什么区别？</a><br><a href="https://www.jianshu.com/p/4afa0679851d">【深度知识】GO语言的goroutine并发原理和调度机制</a><br><a href="https://www.limerence2017.com/2019/11/05/golang17/">图解Go协程调度原理，小白都能理解</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>goroutine</tag>
        <tag>用户态</tag>
        <tag>内核态</tag>
        <tag>线程</tag>
        <tag>协程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程/线程、同步/异步、阻塞/非阻塞</title>
    <url>/2021/05/19/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
    <content><![CDATA[<p>这篇文章我们将重点讨论 <strong>进程/线程、同步/异步、阻塞/非阻塞</strong>问题</p>
<span id="more"></span>

<h1 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>Windows系统中的一个基本概念，它包含着一个运行程序所需要的资源，<strong>进程可以包括一个或多个线程</strong>。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><strong>进程中的基本执行单元，是操作系统分配CPU时间的基本单位，一个进程可以包含若干个线程，在进程入口执行的第一个线程被视为这个进程的主线程。</strong></p>
<p>线程主要是由CPU寄存器、调用栈和线程本地存储器（Thread Local Storage，TLS）组成的。</p>
<ul>
<li><strong>CPU寄存器</strong>主要记录当前所执行线程的状态</li>
<li><strong>调用栈</strong>主要用于维护线程所调用到的内存与数据</li>
<li><strong>TLS</strong>主要用于存放线程的状态信息。</li>
</ul>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p><strong>进程和线程的主要差别在于它们是不同的操作系统资源管理方式</strong>。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。<strong>线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间</strong>，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<ol>
<li><p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</p>
</li>
<li><p>线程的划分尺度小于进程，使得多线程程序的并发性高。</p>
</li>
<li><p>另外，<strong>进程在执行过程中拥有独立的内存单元</strong>，而<strong>多个线程共享内存</strong>，从而极大地提高了程序的运行效率。</p>
</li>
<li><p>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
</li>
<li><p>从逻辑角度来看，<strong>多线程的意义在于一个应用程序中，有多个执行部分可以同时执行</strong>。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>
</li>
</ol>
<h1 id="同步（Sync）和异步（Async）"><a href="#同步（Sync）和异步（Async）" class="headerlink" title="同步（Sync）和异步（Async）"></a>同步（Sync）和异步（Async）</h1><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>所谓同步，就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。</p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>异步与同步相对，当一个异步过程调用发出后，<strong>调用者在没有得到结果之前，就可以继续执行后续操作</strong>。当这个调用完成后，<strong>一般通过状态、通知和回调来通知调用者</strong>。对于异步调用，调用的返回并不受调用者控制。</p>
<p>对于通知调用者的三种方式，具体如下：</p>
<ul>
<li><p>状态</p>
<p>即<strong>监听被调用者的状态（轮询）</strong>，调用者需要每隔一定时间检查一次，效率会很低。</p>
</li>
<li><p>通知</p>
<p>当被调用者执行完成后，<strong>发出通知告知调用者</strong>，无需消耗太多性能。</p>
</li>
<li><p>回调</p>
<p>与通知类似，当被调用者执行完成后，会<strong>调用调用者提供的回调函数</strong>。</p>
</li>
</ul>
<h2 id="JavaScript中的异步"><a href="#JavaScript中的异步" class="headerlink" title="JavaScript中的异步"></a>JavaScript中的异步</h2><p>众所周知，js语言的一大特点就是单线程，那么它的异步是怎么实现的呢？</p>
<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>js中IO设备（输入输出设备）很慢(如Ajax操作从网络读取数据)，不得不等着结果出来，再往下执行。<br>JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，<strong>挂起处于等待中的任务，先运行排在后面的任务</strong>。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。<br>于是，所有任务可以分成两种，</p>
<ul>
<li>一种是<strong>同步任务（synchronous）</strong><br>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务</li>
<li>另一种是<strong>异步任务（asynchronous）</strong><br>异步任务指的是，不进入主线程，而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li>
</ul>
<p>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）</p>
<ol>
<li>所有同步任务都在主线程上执行，形成一个<strong>执行栈（execution context stack）</strong>。</li>
<li>主线程之外，还存在一个”<strong>任务队列”（task queue）</strong>。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li>
<li>一旦”<strong>执行栈</strong>“中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>
<li>主线程不断重复上面的第三步。</li>
</ol>
<p><img src="/2021/05/19/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E/%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.jpg" alt="异步执行过程.jpg"><br>只要主线程空了，就会去读取”任务队列”，这就是js的运行机制。这个过程会不断重复。</p>
<h3 id="事件和回调函数"><a href="#事件和回调函数" class="headerlink" title="事件和回调函数"></a>事件和回调函数</h3><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。</p>
<p>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。</p>
<h4 id="回调函数（callback）"><a href="#回调函数（callback）" class="headerlink" title="回调函数（callback）"></a>回调函数（callback）</h4><p>那些会被主线程挂起来的代码。异步任务必须指定回调函数，当<strong>主线程开始执行异步任务，就是执行对应的回调函数</strong>。</p>
<h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</p>
<p><img src="/2021/05/19/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E/evenloop.png" alt="evenloop"></p>
<p>上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种<strong>外部API</strong>，它们<strong>在”任务队列”中加入各种事件</strong>（click，load，done）。只要栈中的代码执行完毕，主线程就会去<strong>读取”任务队列”<strong>，</strong>依次执行那些事件所对应的回调函数</strong>。</p>
<p>执行栈中的代码（同步任务），总是在读取”任务队列”（异步任务）之前执行。请看下面这个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">req.open(<span class="string">&#x27;GET&#x27;</span>, url);    </span><br><span class="line">req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;    </span><br><span class="line">req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;    </span><br><span class="line">req.send();</span><br></pre></td></tr></table></figure>

<p>上面代码中的<code>req.send</code>方法是Ajax操作向服务器发送数据，它是一个异步任务，意味着只有当前脚本的所有代码执行完，系统才会去读取”任务队列”。所以，它与下面的写法等价。</p>
<pre><code class="js">var req = new XMLHttpRequest();
req.open(&#39;GET&#39;, url);    
req.send();
req.onload = function ()&#123;&#125;;    
req.onerror = function ()&#123;&#125;;    
</code></pre>
<p>也就是说，指定回调函数的部分（onload和onerror），在send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取”任务队列”。</p>
<h2 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别"></a>同步和异步的区别</h2><p>请求发出后，是否需要等待结果，才能继续执行其他操作。</p>
<h1 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h1><p>阻塞和非阻塞这两个概念与<strong>程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关</strong>。</p>
<p>阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong></p>
<p>阻塞调用是指调用结果返回之前，<strong>当前线程会被挂起</strong>。调用线程只有在得到结果之后才会返回。</p>
<p>非阻塞调用指在不能立刻得到结果之前，<strong>直接返回结果</strong>，使该调用不会阻塞当前线程。</p>
<p><strong>同步/异步 关注的是消息通知的机制</strong></p>
<p><strong>阻塞/非阻塞 关注的是程序（线程）等待消息通知时的状态。</strong></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.cnblogs.com/mhq-martin/p/9035640.html">15分钟读懂进程线程、同步异步、阻塞非阻塞、并发并行 - mhq_martin - 博客园 (cnblogs.com)</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈Event Loop</a></li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>进程</tag>
        <tag>JavaScript</tag>
        <tag>同步</tag>
        <tag>异步</tag>
        <tag>阻塞</tag>
        <tag>非阻塞</tag>
        <tag>even loop</tag>
      </tags>
  </entry>
</search>
